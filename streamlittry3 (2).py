# -*- coding: utf-8 -*-
"""streamlittry3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ae2f9LU2zo5GbYULfO8IqmsBrqKmK-V1
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from scipy.stats import norm
from scipy.optimize import fsolve

# ================= Streamlit Sidebar Inputs =================
st.sidebar.title("Options Analysis Dashboard")
ticker = st.sidebar.text_input("Ticker", value="AAPL")
expiry_count = st.sidebar.slider("Expiry Count", 1, 10, 3)
E = st.sidebar.slider("E (Pinning)", 0.001, 0.05, 0.01)
opt_type = st.sidebar.selectbox("Option Type", ["Put", "Call"])

# ================= Black-Scholes Option Pricing =================
def black_scholes_price(S, K, T, r, sigma, option_type='call'):
    if T <= 0 or sigma <= 0:
        raise ValueError("Time to maturity and volatility must be positive.")
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    if option_type.lower() == 'call':
        return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    elif option_type.lower() == 'put':
        return K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)
    else:
        raise ValueError("Invalid option_type. Use 'call' or 'put'.")

# ================= Earnings Expected Move =================
def earnings_expected_move(ticker):
    stock = yf.Ticker(ticker)
    latest_price = stock.history(period="1d")["Close"][-1]
    expiry_dates = stock.options
    option_chain = stock.option_chain(expiry_dates[0])
    calls, puts = option_chain.calls, option_chain.puts
    atm_strike = min(calls['strike'], key=lambda x: abs(x - latest_price))
    atm_call = calls[calls['strike'] == atm_strike]['lastPrice'].values[0]
    atm_put = puts[puts['strike'] == atm_strike]['lastPrice'].values[0]
    expected_move = (atm_call + atm_put) / latest_price
    st.write(f"[Earnings Expected Move] {ticker}: ±{expected_move*100:.2f}%")
    return expected_move

# ================= Volatility Skew & Risk Reversal =================
def vol_skew_and_rr(ticker):
    stock = yf.Ticker(ticker)
    expiry_dates = stock.options
    option_chain = stock.option_chain(expiry_dates[0])
    calls, puts = option_chain.calls, option_chain.puts
    latest_price = stock.history(period="1d")["Close"][-1]
    otm_call_strike = min(calls['strike'], key=lambda x: abs(x - latest_price*1.1))
    otm_put_strike = min(puts['strike'], key=lambda x: abs(x - latest_price*0.9))
    iv_call = calls[calls['strike'] == otm_call_strike]['impliedVolatility'].values[0]
    iv_put = puts[puts['strike'] == otm_put_strike]['impliedVolatility'].values[0]
    risk_reversal = iv_call - iv_put
    st.write(f"[Vol Skew & RR] Call IV: {iv_call:.2%}, Put IV: {iv_put:.2%}, RR: {risk_reversal:.2%}")
    return iv_call, iv_put, risk_reversal

# ================= Max Pain Calculation =================
def calculate_max_pain(ticker, expiry):
    stock = yf.Ticker(ticker)
    option_chain = stock.option_chain(expiry)
    calls, puts = option_chain.calls, option_chain.puts
    strikes = sorted(set(calls['strike']).union(set(puts['strike'])))
    pain = []
    for K in strikes:
        call_loss = np.sum(np.maximum(0, K - calls['strike']) * calls['openInterest'])
        put_loss = np.sum(np.maximum(0, puts['strike'] - K) * puts['openInterest'])
        pain.append(call_loss + put_loss)
    min_pain_idx = np.argmin(pain)
    max_pain_price = strikes[min_pain_idx]
    st.write(f"[Max Pain] {ticker} ({expiry}) Max Pain Price: {max_pain_price}")
    fig, ax = plt.subplots(figsize=(10, 5))
    ax.plot(strikes, pain, marker='o')
    ax.axvline(x=max_pain_price, color='r', linestyle='--', label=f"Max Pain Price ({max_pain_price})")
    ax.set_title(f"Max Pain Theory: {ticker} ({expiry})")
    ax.set_xlabel("Strike Price")
    ax.set_ylabel("Total Option Holder Loss (Pain)")
    ax.legend()
    ax.grid(True)
    st.pyplot(fig)
    return max_pain_price

# ================= Put-Call Parity & BS Implied Price =================
def implied_price_analysis(ticker, expiry):
    aapl = yf.Ticker(ticker)
    dividend_yield = aapl.dividends[-4:].sum() / aapl.history(period="1d")['Close'].iloc[-1] if len(aapl.dividends) > 0 else 0
    option_chain = aapl.option_chain(expiry)
    calls, puts = option_chain.calls, option_chain.puts
    S_market = aapl.history(period="1d")['Close'].iloc[-1]
    atm_call = calls.iloc[(calls['strike'] - S_market).abs().argmin()]
    atm_put = puts.iloc[(puts['strike'] - S_market).abs().argmin()]
    K = atm_call['strike']
    expiry_date = datetime.strptime(expiry, "%Y-%m-%d")
    T = (expiry_date - datetime.now()).days / 365
    t_bill = yf.Ticker("^IRX")
    r = t_bill.history(period="1d")['Close'].iloc[-1] / 100 if not t_bill.history(period="1d").empty else 0.02
    C = atm_call['lastPrice']
    P = atm_put['lastPrice']
    S_parity = C - P + K * np.exp(-(r - dividend_yield) * T)
    sigma = atm_call['impliedVolatility']
    def objective(S):
        d1 = (np.log(S / K) + (r - dividend_yield + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
        d2 = d1 - sigma * np.sqrt(T)
        return S * np.exp(-dividend_yield*T) * norm.cdf(d1) - K * np.exp(-r*T) * norm.cdf(d2) - C
    S_bs = fsolve(objective, S_market)[0]
    results = {
        "Market Price": round(S_market, 2),
        "Dividend Yield": f"{dividend_yield*100:.2f}%",
        "Risk-Free Rate": f"{r*100:.2f}%",
        "Put-Call Implied Price": round(S_parity, 2),
        "BS Model Implied Price": round(S_bs, 2),
        "Strike Price Used": K,
        "Expiration Date": expiry,
        "Call Option Price": C,
        "Put Option Price": P,
        "Implied Volatility (IV)": f"{sigma*100:.2f}%"
    }
    st.write("[Implied Price Analysis]")
    st.dataframe(pd.DataFrame(list(results.items()), columns=["Metric", "Value"]))
    return S_parity, S_bs

# ================= Option Market Analysis Report =================
def generate_option_report(ticker, expiries, max_pain_prices, pinning_probs, bs_call, bs_put, earnings_move, vol_rr, call_iv, put_iv, current_price):
    report = f"## Option Market Analysis Report: {ticker}\n\n"
    avg_max_pain = np.mean(max_pain_prices)
    report += f"### 1️⃣ Max Pain\n到期日 {expiries} 的 Max Pain: {max_pain_prices}, 平均值: ${avg_max_pain:.2f}\n"
    report += "股价高于痛点: 下行压力\n\n" if current_price > avg_max_pain else "股价低于痛点: 上行回归可能\n\n"
    report += "### 2️⃣ Pinning Probability\n" + "\n".join([f"{e}: {p*100:.2f}%" for e,p in zip(expiries, pinning_probs)]) + "\n\n"
    report += f"### 3️⃣ Black-Scholes 定价\nCall: ${bs_call:.2f}, Put: ${bs_put:.2f}\n\n"
    report += f"### 4️⃣ Earnings Move\n预期波动: ±{earnings_move:.2f}%\n\n"
    report += f"### 5️⃣ Vol Skew & RR\nCall IV: {call_iv:.2f}%, Put IV: {put_iv:.2f}%, RR: {vol_rr:.2f}%\n\n"
    return report

# ================= Combined Analysis =================
if st.sidebar.button("Run Analysis"):
    ticker = ticker.upper()
    stock = yf.Ticker(ticker)
    expirations = stock.options

    # Historical data
    end_date = datetime.today()
    start_date = end_date - timedelta(days=365)
    stock_data = yf.download(ticker, start=start_date, end=end_date)
    st.write("### Recent Stock Data")
    st.dataframe(stock_data.tail())
    st.write("Available option expiry dates:", expirations)

    expiry = expirations[0]
    option_chain = stock.option_chain(expiry)
    calls, puts = option_chain.calls, option_chain.puts

    max_oi_call = calls.loc[calls['openInterest'].idxmax()]
    max_oi_put = puts.loc[puts['openInterest'].idxmax()]
    st.write(f"Call Max OI Strike: {max_oi_call['strike']}")
    st.write(f"Put Max OI Strike: {max_oi_put['strike']}")

    # Plot price and max OI
    fig, ax = plt.subplots(figsize=(10,6))
    ax.plot(stock_data.tail(10).index, stock_data.tail(10)['Close'], label=f"{ticker} Close Price", linewidth=2)
    ax.axhline(y=max_oi_call['strike'], color='r', linestyle='--', label=f"Call Max OI ({max_oi_call['strike']})")
    ax.axhline(y=max_oi_put['strike'], color='g', linestyle='--', label=f"Put Max OI ({max_oi_put['strike']})")
    ax.set_title(f"{ticker} Price vs Option Max OI Strikes")
    ax.set_xlabel("Date")
    ax.set_ylabel("Price (USD)")
    ax.legend()
    ax.grid(True)
    st.pyplot(fig)

    # Pinning probability
    results = []
    max_pain_prices, pinning_probs, expiries = [], [], []
    for expiry in expirations[:expiry_count]:
        expiry_date = datetime.strptime(expiry, "%Y-%m-%d")
        option_chain = stock.option_chain(expiry)
        options_df = option_chain.puts if opt_type == 'Put' else option_chain.calls
        max_oi = options_df.loc[options_df['openInterest'].idxmax()].squeeze()
        K = float(max_oi['strike'])
        OI = float(max_oi['openInterest'])
        IV = float(max_oi['impliedVolatility'])
        price_window = stock_data.loc[:expiry_date].tail(5)
        if price_window.empty:
            continue
        S0 = float(price_window['Close'].iloc[-1])
        V = float(price_window['Volume'].mean())
        today = price_window.index[-1].to_pydatetime()
        days_to_expiry = max((expiry_date - today).days, 1)
        T = days_to_expiry / 252
        zeta0 = np.log(S0 / K) / (IV * np.sqrt(T))
        beta = (E * OI) / (IV * np.sqrt(T) * V)
        P_pinning = 1 - np.exp(-2 * beta * np.exp(-zeta0**2 / 2))
        pinning_probs.append(P_pinning)
        expiries.append(expiry)
        expiry_price_data = stock_data.loc[expiry_date:expiry_date]
        expiry_price = float(expiry_price_data['Close'].iloc[0]) if not expiry_price_data.empty else None
        deviation = abs(expiry_price - K) / K * 100 if expiry_price else None
        results.append({
            "expiry": expiry,
            "S0 (pre-expiry)": S0,
            "K (max OI)": K,
            "OI": OI,
            "IV": IV,
            "Volume": V,
            "Days_to_expiry": days_to_expiry,
            "P_pinning (%)": P_pinning * 100,
            "Expiry_price": expiry_price,
            "Deviation (%)": deviation
        })
        max_pain_prices.append(calculate_max_pain(ticker, expiry))
        implied_price_analysis(ticker, expiry)

    df_results = pd.DataFrame(results)
    st.write("### Pinning Probability and Strike Analysis")
    st.dataframe(df_results)

    fig, ax = plt.subplots(figsize=(12,6))
    ax.plot(df_results['expiry'], df_results['P_pinning (%)'], marker='o', label='Pinning Probability (%)')
    ax.plot(df_results['expiry'], df_results['Deviation (%)'], marker='s', label='Price Deviation (%)')
    ax.set_xticklabels(df_results['expiry'], rotation=45)
    ax.set_xlabel("Option Expiry Date")
    ax.set_ylabel("Percentage (%)")
    ax.set_title(f"{ticker}: Pinning Probability vs Deviation ({opt_type}, E={E})")
    ax.legend()
    ax.grid(True)
    st.pyplot(fig)

    latest_price = stock.history(period="1d")["Close"][-1]
    atm_strike = float(latest_price)
    T = 30/252; r = 0.02; sigma = 0.25
    call_price = black_scholes_price(latest_price, atm_strike, T, r, sigma, 'call')
    put_price = black_scholes_price(latest_price, atm_strike, T, r, sigma, 'put')
    st.write(f"[Black-Scholes] Call: {call_price:.2f}, Put: {put_price:.2f}")

    earn_move = earnings_expected_move(ticker)
    iv_call, iv_put, rr = vol_skew_and_rr(ticker)
    report = generate_option_report(ticker, expiries, max_pain_prices, pinning_probs, call_price, put_price, earn_move*100, rr*100, iv_call*100, iv_put*100, latest_price)
    st.markdown(report)
import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from scipy.stats import norm
from scipy.optimize import fsolve

# ================= Streamlit Sidebar Inputs =================
st.sidebar.title("Options Analysis Dashboard")
ticker = st.sidebar.text_input("Ticker", value="AAPL")
expiry_count = st.sidebar.slider("Number of Expiries for Analysis", 1, 10, 3)
E = st.sidebar.slider("E (Pinning)", 0.001, 0.05, 0.01)
opt_type = st.sidebar.selectbox("Option Type", ["Put", "Call"])
report_expiry = st.sidebar.selectbox("Select Expiry for Valuation", [])

# ================= Black-Scholes Option Pricing =================
def black_scholes_price(S, K, T, r, sigma, option_type='call'):
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    if option_type.lower() == 'call':
        return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    else:
        return K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# ================= Generate Detailed Report =================
def generate_option_report(ticker, expiries, max_pain_prices, pinning_probs,
                           bs_call, bs_put, earnings_move, vol_skew_rr,
                           call_iv, put_iv, current_price, forecast_days=30):
    report = f"📊 **Option Market Analysis Report: {ticker}**\n\n"
    avg_max_pain = np.mean(max_pain_prices)
    expiry_str = ", ".join(expiries)

    # 1️⃣ Max Pain
    report += f"1️⃣ **Max Pain (最大痛点价):**\n"
    report += f"- 到期日分别为 {expiries} 的 Max Pain 价格: {max_pain_prices}\n"
    report += f"- 平均最大痛点价约为 **${avg_max_pain:.2f}**，当前股价为 **${current_price:.2f}**。\n"
    report += f"⏳ **保质期:** 基于上述到期日的期权结构，有效期至最近的到期日 {expiries[0]}。\n"
    if current_price > avg_max_pain:
        report += "👉 股价高于平均痛点价，短期有下行回归压力。\n\n"
    else:
        report += "👉 股价低于平均痛点价，可能向上回归至痛点水平。\n\n"

    # 2️⃣ Pinning Probability
    report += "2️⃣ **Pinning Probability (钉住概率):**\n"
    for e, p in zip(expiries, pinning_probs):
        report += f"- {e}: 钉住概率 **{p*100:.2f}%**\n"
    report += f"⏳ **保质期:** 钉住概率预测仅适用于各自的到期日 ({expiry_str})。\n\n"

    # 3️⃣ Black-Scholes Pricing
    report += f"3️⃣ **Black-Scholes 定价:**\n- Call **${bs_call:.2f}**，Put **${bs_put:.2f}**。\n⏳ **保质期:** 即期估值，需每日更新。\n\n"

    # 4️⃣ Earnings Expected Move
    price_lower = current_price * (1 - earnings_move/100)
    price_upper = current_price * (1 + earnings_move/100)
    report += f"4️⃣ **Earnings Expected Move (财报预期波动):**\n- 隐含波动区间 ±{earnings_move:.2f}%: **${price_lower:.2f} - ${price_upper:.2f}**。\n⏳ **保质期:** 财报日前后约1周。\n\n"

    # 5️⃣ Vol Skew & RR
    report += f"5️⃣ **Vol Skew & Risk Reversal:**\n- Call IV: **{call_iv:.2f}%**, Put IV: **{put_iv:.2f}%**。\n- RR: **{vol_skew_rr:.2f}%** ({'看涨' if vol_skew_rr>0 else '看跌/防御'}).\n\n"

    # 6️⃣ Forecast
    forecast_lower = current_price * (1 + vol_skew_rr/200 - earnings_move/200)
    forecast_upper = current_price * (1 - vol_skew_rr/200 + earnings_move/200)
    expiry_date = (datetime.today() + timedelta(days=forecast_days)).strftime("%Y-%m-%d")
    report += f"6️⃣ **{forecast_days}天价格预测区间:**\n- **${forecast_lower:.2f} - ${forecast_upper:.2f}**。\n⏳ **保质期:** 至 **{expiry_date}**。\n\n---\n📌 **结论:** 市场{'防御/看跌' if vol_skew_rr<0 else '偏多'}，建议相应策略布局。"

    return report

# ================= Analysis Execution =================
st.sidebar.title("Options Analysis")
ticker = st.sidebar.text_input("Ticker", value="AAPL", key="ticker_input")
if ticker:
    stock = yf.Ticker(ticker)
    expirations = stock.options
    st.sidebar.write("Available expiries:", expirations)

    selected_expiries = st.sidebar.multiselect("Select Expiries for Analysis", expirations, default=expirations[:3], key="expiries_select")
    valuation_expiry = st.sidebar.selectbox("Select Expiry for Valuation", expirations, key="valuation_expiry")

    if st.sidebar.button("Run Analysis", key="run_analysis"):
        current_price = stock.history(period="1d")["Close"][-1]
        # Placeholder demo values (replace with real calculations in full integration)
        max_pain_prices = [current_price-2 for _ in selected_expiries]
        pinning_probs = [0.012 for _ in selected_expiries]
        bs_call, bs_put = 7.43, 6.94
        earnings_move = 4.17
        vol_skew_rr, call_iv, put_iv = -13.09, 67.19, 80.27

        report = generate_option_report(ticker, selected_expiries, max_pain_prices, pinning_probs,
                                        bs_call, bs_put, earnings_move, vol_skew_rr,
                                        call_iv, put_iv, current_price)
        st.markdown(report)
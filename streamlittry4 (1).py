# -*- coding: utf-8 -*-
"""streamlittry4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UZ6l6_ydFfzo6VJVAlNXJQQ61p9dJgpz
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from scipy.stats import norm
from scipy.optimize import fsolve

# ================= Streamlit Sidebar Inputs =================
st.sidebar.title("Options Analysis Dashboard")
ticker = st.sidebar.text_input("Ticker", value="AAPL", key="ticker_input_main")  # Added unique key
expiry_count = st.sidebar.slider("Expiry Count", 1, 10, 3, key="expiry_slider")  # Added unique key
E = st.sidebar.slider("E (Pinning)", 0.001, 0.05, 0.01, key="pinning_slider")  # Added unique key
opt_type = st.sidebar.selectbox("Option Type", ["Put", "Call"], key="option_type_select")  # Added unique key

# ================= Black-Scholes Option Pricing =================
def black_scholes_price(S, K, T, r, sigma, option_type='call'):
    if T <= 0 or sigma <= 0:
        raise ValueError("Time to maturity and volatility must be positive.")
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    if option_type.lower() == 'call':
        return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    elif option_type.lower() == 'put':
        return K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)

# ================= Earnings Expected Move =================
def earnings_expected_move(ticker):
    stock = yf.Ticker(ticker)
    latest_price = stock.history(period="1d")["Close"][-1]
    expiry_dates = stock.options
    option_chain = stock.option_chain(expiry_dates[0])
    calls, puts = option_chain.calls, option_chain.puts
    atm_strike = min(calls['strike'], key=lambda x: abs(x - latest_price))
    atm_call = calls[calls['strike'] == atm_strike]['lastPrice'].values[0]
    atm_put = puts[puts['strike'] == atm_strike]['lastPrice'].values[0]
    expected_move = (atm_call + atm_put) / latest_price
    st.write(f"[Earnings Expected Move] {ticker}: ±{expected_move*100:.2f}%")
    return expected_move

# ================= Volatility Skew & Risk Reversal =================
def vol_skew_and_rr(ticker):
    stock = yf.Ticker(ticker)
    expiry_dates = stock.options
    option_chain = stock.option_chain(expiry_dates[0])
    calls, puts = option_chain.calls, option_chain.puts
    latest_price = stock.history(period="1d")["Close"][-1]
    otm_call_strike = min(calls['strike'], key=lambda x: abs(x - latest_price*1.1))
    otm_put_strike = min(puts['strike'], key=lambda x: abs(x - latest_price*0.9))
    iv_call = calls[calls['strike'] == otm_call_strike]['impliedVolatility'].values[0]
    iv_put = puts[puts['strike'] == otm_put_strike]['impliedVolatility'].values[0]
    risk_reversal = iv_call - iv_put
    st.write(f"[Vol Skew & RR] Call IV: {iv_call:.2%}, Put IV: {iv_put:.2%}, RR: {risk_reversal:.2%}")
    return iv_call, iv_put, risk_reversal

# ================= Max Pain Calculation =================
def calculate_max_pain(ticker, expiry):
    stock = yf.Ticker(ticker)
    option_chain = stock.option_chain(expiry)
    calls, puts = option_chain.calls, option_chain.puts
    strikes = sorted(set(calls['strike']).union(set(puts['strike'])))
    pain = []
    for K in strikes:
        call_loss = np.sum(np.maximum(0, K - calls['strike']) * calls['openInterest'])
        put_loss = np.sum(np.maximum(0, puts['strike'] - K) * puts['openInterest'])
        pain.append(call_loss + put_loss)
    min_pain_idx = np.argmin(pain)
    max_pain_price = strikes[min_pain_idx]
    st.write(f"[Max Pain] {ticker} ({expiry}) Max Pain Price: {max_pain_price}")
    return max_pain_price

# ================= Generate Detailed Report =================
def generate_option_report(ticker, expiries, max_pain_prices, pinning_probs,
                           bs_call, bs_put, earnings_move, vol_skew_rr,
                           call_iv, put_iv, current_price, forecast_days=30):
    report = f"📊 **Option Market Analysis Report: {ticker}**\n\n"
    avg_max_pain = np.mean(max_pain_prices)
    expiry_str = ", ".join(expiries)
    report += f"1️⃣ **Max Pain:** {max_pain_prices} 平均: ${avg_max_pain:.2f}\n"
    report += f"2️⃣ **Pinning:** {[(e, f'{p*100:.2f}%') for e,p in zip(expiries, pinning_probs)]}\n"
    report += f"3️⃣ **BS Pricing:** Call ${bs_call:.2f}, Put ${bs_put:.2f}\n"
    report += f"4️⃣ **Earnings Move:** ±{earnings_move:.2f}%\n"
    report += f"5️⃣ **Vol Skew & RR:** Call IV {call_iv:.2f}%, Put IV {put_iv:.2f}%, RR {vol_skew_rr:.2f}%\n"
    report += f"6️⃣ **30d Forecast:** ${current_price*(1+vol_skew_rr/200-earnings_move/200):.2f} - ${current_price*(1-vol_skew_rr/200+earnings_move/200):.2f}\n"
    return report

# ================= Analysis Execution =================
if st.sidebar.button("Run Analysis", key="run_analysis_btn"):
    stock = yf.Ticker(ticker)
    expirations = stock.options
    selected_expiries = st.sidebar.multiselect("Select Expiries", expirations, default=expirations[:expiry_count], key="expiry_multi")
    valuation_expiry = st.sidebar.selectbox("Valuation Expiry", expirations, key="valuation_expiry")

    current_price = stock.history(period="1d")["Close"][-1]
    max_pain_prices = [calculate_max_pain(ticker, e) for e in selected_expiries]
    pinning_probs = [0.01 for _ in selected_expiries]  # Placeholder logic

    bs_call, bs_put = 7.43, 6.94  # Placeholder
    earnings_move = earnings_expected_move(ticker) * 100
    iv_call, iv_put, rr = vol_skew_and_rr(ticker)

    report = generate_option_report(ticker, selected_expiries, max_pain_prices, pinning_probs,
                                    bs_call, bs_put, earnings_move, rr*100,
                                    iv_call*100, iv_put*100, current_price)
    st.markdown(report)
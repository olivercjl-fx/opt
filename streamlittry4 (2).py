# -*- coding: utf-8 -*-
"""streamlittry4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UZ6l6_ydFfzo6VJVAlNXJQQ61p9dJgpz
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from scipy.stats import norm
from scipy.optimize import fsolve

# ================= Streamlit Sidebar Inputs =================
st.sidebar.title("Options Analysis Dashboard")
ticker = st.sidebar.text_input("Ticker", value="AAPL", key="ticker_input")
expiry_count = st.sidebar.slider("Expiry Count", 1, 10, 3, key="expiry_count")
E = st.sidebar.slider("E (Pinning)", 0.001, 0.05, 0.01, key="pinning")
opt_type = st.sidebar.selectbox("Option Type", ["Put", "Call"], key="opt_type")

# Load expirations dynamically once ticker is entered
expirations = []
if ticker:
    stock = yf.Ticker(ticker)
    expirations = stock.options if stock.options else []

# Expiry selection BEFORE Run Analysis
selected_expiries = st.sidebar.multiselect("Select Expiries for Analysis", expirations, default=expirations[:3] if expirations else [], key="expiries_select")
valuation_expiry = st.sidebar.selectbox("Select Expiry for Valuation", expirations, key="valuation_expiry")

# Run button AFTER expiry selections
run_analysis = st.sidebar.button("Run Analysis", key="run_analysis")

# ================= Black-Scholes Option Pricing =================
def black_scholes_price(S, K, T, r, sigma, option_type='call'):
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    if option_type.lower() == 'call':
        return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    else:
        return K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)

# ================= Max Pain Calculation =================
def calculate_max_pain(ticker, expiry):
    stock = yf.Ticker(ticker)
    option_chain = stock.option_chain(expiry)
    calls, puts = option_chain.calls, option_chain.puts
    strikes = sorted(set(calls['strike']).union(set(puts['strike'])))
    pain = []
    for K in strikes:
        call_loss = np.sum(np.maximum(0, K - calls['strike']) * calls['openInterest'])
        put_loss = np.sum(np.maximum(0, puts['strike'] - K) * puts['openInterest'])
        pain.append(call_loss + put_loss)
    min_pain_idx = np.argmin(pain)
    return strikes[min_pain_idx]

# ================= Generate Option Report =================
def generate_option_report(ticker, expiries, max_pain_prices, pinning_probs,
                           bs_call, bs_put, earnings_move, vol_skew_rr,
                           call_iv, put_iv, current_price, forecast_days=30):
    report = f"ğŸ“Š **Option Market Analysis Report: {ticker}**\n\n"
    avg_max_pain = np.mean(max_pain_prices)
    expiry_str = ", ".join(expiries)
    report += f"1ï¸âƒ£ **Max Pain (æœ€å¤§ç—›ç‚¹ä»·):**\n- åˆ°æœŸæ—¥ {expiries} çš„ Max Pain ä»·æ ¼: {max_pain_prices}\n- å¹³å‡æœ€å¤§ç—›ç‚¹ä»· **${avg_max_pain:.2f}**ï¼Œå½“å‰è‚¡ä»· **${current_price:.2f}**ã€‚\nâ³ æœ‰æ•ˆæœŸè‡³æœ€è¿‘çš„åˆ°æœŸæ—¥ {expiries[0]}.\n"
    report += "ğŸ‘‰ è‚¡ä»·é«˜äºå¹³å‡ç—›ç‚¹ä»·ï¼Œä¸‹è¡Œå‹åŠ›ã€‚\n\n" if current_price > avg_max_pain else "ğŸ‘‰ è‚¡ä»·ä½äºå¹³å‡ç—›ç‚¹ä»·ï¼Œä¸Šè¡Œæ½œåŠ›ã€‚\n\n"
    report += "2ï¸âƒ£ **Pinning Probability:**\n" + "\n".join([f"- {e}: {p*100:.2f}%" for e, p in zip(expiries, pinning_probs)]) + f"\nâ³ é€‚ç”¨äºåˆ°æœŸæ—¥: {expiry_str}\n\n"
    report += f"3ï¸âƒ£ **Black-Scholes å®šä»·:** Call ${bs_call:.2f}, Put ${bs_put:.2f}\nâ³ æ¯æ—¥æ›´æ–°ã€‚\n\n"
    price_lower = current_price * (1 - earnings_move/100)
    price_upper = current_price * (1 + earnings_move/100)
    report += f"4ï¸âƒ£ **Earnings Move:** Â±{earnings_move:.2f}%, åŒºé—´: ${price_lower:.2f}-${price_upper:.2f}\n\n"
    report += f"5ï¸âƒ£ **Vol Skew & RR:** Call IV {call_iv:.2f}%, Put IV {put_iv:.2f}%, RR {vol_skew_rr:.2f}%\n\n"
    forecast_lower = current_price * (1 + vol_skew_rr/200 - earnings_move/200)
    forecast_upper = current_price * (1 - vol_skew_rr/200 + earnings_move/200)
    expiry_date = (datetime.today() + timedelta(days=forecast_days)).strftime("%Y-%m-%d")
    report += f"6ï¸âƒ£ **{forecast_days}å¤©é¢„æµ‹:** ${forecast_lower:.2f}-${forecast_upper:.2f} (è‡³ {expiry_date})\n\n"
    report += "---\nğŸ“Œ **ç»“è®º:** " + ("é˜²å¾¡/çœ‹è·Œç­–ç•¥" if vol_skew_rr<0 else "åå¤šç­–ç•¥")
    return report

# ================= Run Analysis =================
if run_analysis and ticker and selected_expiries:
    stock = yf.Ticker(ticker)
    current_price = stock.history(period="1d")["Close"][-1]

    # Example placeholders (replace with real calc logic)
    max_pain_prices = [calculate_max_pain(ticker, e) for e in selected_expiries]
    pinning_probs = [0.012 for _ in selected_expiries]
    bs_call, bs_put = 7.43, 6.94
    earnings_move = 4.17
    vol_skew_rr, call_iv, put_iv = -13.09, 67.19, 80.27

    report = generate_option_report(ticker, selected_expiries, max_pain_prices, pinning_probs,
                                    bs_call, bs_put, earnings_move, vol_skew_rr,
                                    call_iv, put_iv, current_price)
    st.markdown(report)
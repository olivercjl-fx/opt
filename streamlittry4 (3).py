# -*- coding: utf-8 -*-
"""streamlittry4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UZ6l6_ydFfzo6VJVAlNXJQQ61p9dJgpz
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from scipy.stats import norm
from scipy.optimize import fsolve

# ================= Streamlit Sidebar Inputs =================
st.sidebar.title("Options Analysis Dashboard")
ticker = st.sidebar.text_input("Ticker", value="AAPL")
expiry_count = st.sidebar.slider("Expiry Count", 1, 10, 3)
E = st.sidebar.slider("E (Pinning)", 0.001, 0.05, 0.01)
opt_type = st.sidebar.selectbox("Option Type", ["Put", "Call"])
anticipation_method = st.sidebar.multiselect("Price Anticipation Methods", ["Max Pain", "Pinning Probability", "BS Implied"], default=["Max Pain", "BS Implied"])
forecast_days = st.sidebar.slider("Forecast Days", 10, 90, 30)

# ================= Black-Scholes Option Pricing =================
def black_scholes_price(S, K, T, r, sigma, option_type='call'):
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    if option_type.lower() == 'call':
        return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    else:
        return K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)

# ================= Pinning Probability =================
def calculate_pinning_probability(S0, K, OI, IV, V, T, E):
    zeta0 = np.log(S0 / K) / (IV * np.sqrt(T))
    beta = (E * OI) / (IV * np.sqrt(T) * V)
    return 1 - np.exp(-2 * beta * np.exp(-zeta0**2 / 2))

# ================= Analysis Execution =================
if st.sidebar.button("Run Analysis"):
    stock = yf.Ticker(ticker)
    expirations = stock.options
    st.sidebar.write("Available Expiries:", expirations)
    selected_expiries = st.sidebar.multiselect("Select Expiries for Analysis", expirations, default=expirations[:expiry_count])

    current_price = stock.history(period="1d")["Close"][-1]
    anticipation_data = []

    for expiry in selected_expiries:
        option_chain = stock.option_chain(expiry)
        calls, puts = option_chain.calls, option_chain.puts
        max_oi_call = calls.loc[calls['openInterest'].idxmax()]
        max_oi_put = puts.loc[puts['openInterest'].idxmax()]

        K = max_oi_call['strike'] if opt_type == 'Call' else max_oi_put['strike']
        IV = max_oi_call['impliedVolatility'] if opt_type == 'Call' else max_oi_put['impliedVolatility']
        OI = max_oi_call['openInterest'] if opt_type == 'Call' else max_oi_put['openInterest']

        expiry_date = datetime.strptime(expiry, "%Y-%m-%d")
        days_to_expiry = max((expiry_date - datetime.today()).days, 1)
        T = days_to_expiry / 252

        V = stock.history(period="1mo")["Volume"].mean()
        pin_prob = calculate_pinning_probability(current_price, K, OI, IV, V, T, E)
        bs_price = black_scholes_price(current_price, K, T, 0.02, IV, opt_type.lower())

        anticipation_data.append({
            "expiry": expiry,
            "pinning_price": K,
            "pinning_prob": pin_prob,
            "bs_price": bs_price,
            "avg_price": (K + bs_price) / 2
        })

    df_anticipation = pd.DataFrame(anticipation_data)

    # Plot anticipation
    fig, ax = plt.subplots(figsize=(10,6))
    x_dates = [datetime.today() + timedelta(days=i) for i in range(0, forecast_days, forecast_days//len(df_anticipation))]

    for method in anticipation_method:
        if method == "Max Pain":
            ax.plot(x_dates, [df_anticipation['pinning_price'].mean()] * len(x_dates), label="Max Pain Price")
        elif method == "Pinning Probability":
            ax.plot(x_dates, [df_anticipation['pinning_price'].mean()] * len(x_dates), '--', label="Pinning-Based")
        elif method == "BS Implied":
            ax.plot(x_dates, [df_anticipation['bs_price'].mean()] * len(x_dates), label="BS Implied Price")

    # Average anticipation
    ax.plot(x_dates, [df_anticipation['avg_price'].mean()] * len(x_dates), 'k-.', label="Average Anticipation")
    ax.axhline(current_price, color='gray', linestyle=':', label="Current Price")

    ax.set_title(f"Price Anticipation: {ticker}")
    ax.set_xlabel("Date")
    ax.set_ylabel("Price")
    ax.legend()
    ax.grid(True)
    st.pyplot(fig)

    st.dataframe(df_anticipation)
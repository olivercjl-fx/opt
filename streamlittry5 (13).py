# -*- coding: utf-8 -*-
"""streamlittry5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14hvwpG5eq6bbkpVXWxWdLAWe6KoHmDuq
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from scipy.stats import norm
from scipy.optimize import fsolve, curve_fit
# ================= 获取无风险利率与股息率 =================
def get_risk_free_and_dividend(ticker):
    # 无风险利率 (3M T-Bill)
    tbill = yf.Ticker("^IRX")  # 3个月国库券
    r = tbill.history(period="1d")['Close'].iloc[-1] / 100  # 转换为小数

    # 股息率 (Dividend Yield)
    stock = yf.Ticker(ticker)
    try:
        div_yield = stock.info.get("dividendYield", 0.0) or 0.0  # 若无分红返回0
    except:
        div_yield = 0.0
    return r, div_yield
# ================= Streamlit Sidebar Inputs =================
st.sidebar.title("Options Analysis Dashboard")
ticker = st.sidebar.text_input("Ticker", value="AAPL")
expiry_count = st.sidebar.slider("Expiry Count", 1, 10, 3)
forecast_days = st.sidebar.slider("Forecast Days", 10, 90, 30)
E = st.sidebar.slider("E (Pinning)", 0.001, 0.05, 0.01)
opt_type = st.sidebar.selectbox("Option Type", ["Put", "Call"])

# Ensure ticker is valid before fetching data
if ticker:
    stock = yf.Ticker(ticker)
    try:
        expirations = stock.options
        st.sidebar.write("Available Expiries:", expirations)
        selected_expiries = st.sidebar.multiselect(
            "Select Expiries for Analysis", expirations, default=expirations[:expiry_count]
        )
        valuation_expiry = st.sidebar.selectbox("Select Expiry for Valuation", expirations)
    except Exception as e:
        st.error(f"Error fetching options data: {e}")
        selected_expiries, valuation_expiry = [], None
else:
    st.stop()

# ================= Option Strategy Builder =================
st.sidebar.subheader("Option Strategy Builder")
strategy = st.sidebar.selectbox("Select Strategy", ["Single Call", "Single Put", "Vertical Spread", "Straddle"])
strike_price = st.sidebar.number_input("Strike Price", min_value=1.0, value=100.0)
premium = st.sidebar.number_input("Option Premium", min_value=0.0, value=5.0)
if strategy == "Vertical Spread":
    strike_price_2 = st.sidebar.number_input("Second Strike Price", min_value=1.0, value=105.0)
    premium_2 = st.sidebar.number_input("Second Option Premium", min_value=0.0, value=3.0)
if st.sidebar.button("Build Option"):
    price_range = np.linspace(strike_price * 0.8, strike_price * 1.2, 100)
    payoff = None
    if strategy == "Single Call":
        payoff = np.maximum(price_range - strike_price, 0) - premium
    elif strategy == "Single Put":
        payoff = np.maximum(strike_price - price_range, 0) - premium
    elif strategy == "Vertical Spread":
        payoff = (
            np.maximum(price_range - strike_price, 0) - premium
        ) - (
            np.maximum(price_range - strike_price_2, 0) - premium_2
        )
    elif strategy == "Straddle":
        payoff = (
            np.maximum(price_range - strike_price, 0) - premium
        ) + (
            np.maximum(strike_price - price_range, 0) - premium
        )
    fig, ax = plt.subplots(figsize=(8, 4))
    ax.plot(price_range, payoff, label=strategy)
    ax.axhline(0, color='black', linestyle='--')
    ax.set_title(f"Payoff Diagram: {strategy}")
    ax.set_xlabel("Underlying Price")
    ax.set_ylabel("Profit / Loss")
    ax.legend()
    st.pyplot(fig)

# ================= Black-Scholes Pricing =================
def black_scholes_price(S, K, T, r, q, sigma, option_type='call'):
    # q 为股息率
    d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    if option_type.lower() == 'call':
        return S * np.exp(-q*T) * norm.cdf(d1) - K * np.exp(-r*T) * norm.cdf(d2)
    return K * np.exp(-r*T) * norm.cdf(-d2) - S * np.exp(-q*T) * norm.cdf(-d1)


# ================= Fetch & Volume Analysis =================
def fetch_stock_data(ticker, period="6mo", interval="1h"):
    df = yf.download(ticker, period=period, interval=interval)
    if df.empty:
        st.warning(f"[错误] 无法获取 {ticker} 数据。")
        return pd.DataFrame()
    df.reset_index(inplace=True)
    return df

def compute_volume_profile(df, bins=50):
    if df.empty:
        return None, None, None
    hist, edges = np.histogram(df['Close'], bins=bins, weights=df['Volume'])
    poc = float((edges[np.argmax(hist)] + edges[np.argmax(hist) + 1]) / 2)
    total = hist.sum()
    sorted_idx = np.argsort(hist)[::-1]
    cum = np.cumsum(hist[sorted_idx])
    va_idx = sorted_idx[cum <= total * 0.7]
    va_prices = [(edges[i] + edges[i + 1]) / 2 for i in va_idx]
    return poc, float(max(va_prices)), float(min(va_prices))

def calculate_max_pain(calls, puts):
    strikes = sorted(set(calls['strike']).union(set(puts['strike'])))
    pain_list = []
    for strike in strikes:
        call_pain = ((calls['strike'] - strike).clip(lower=0) * calls['openInterest']).sum()
        put_pain = ((strike - puts['strike']).clip(lower=0) * puts['openInterest']).sum()
        pain_list.append(call_pain + put_pain)
    return strikes[np.argmin(pain_list)]


# ================= Generate Detailed Report =================
def generate_option_report(
    ticker, expiries, max_pain_prices, pinning_probs,
    bs_call, bs_put, earnings_move, vol_skew_rr,
    call_iv, put_iv, current_price,
    poc, vah, val, max_call, max_put,
    forecast_days=30
):
    report = f"📊 **Option Market Analysis Report: {ticker}**\n\n"
    avg_max_pain = float(np.mean(max_pain_prices))
    expiry_str = ", ".join(expiries)
    low_move = current_price * (1 - earnings_move/100)
    high_move = current_price * (1 + earnings_move/100)
    forecast_low = min(avg_max_pain, low_move)
    forecast_high = max(avg_max_pain, high_move)

    # 1️⃣ Max Pain
    report += "1️⃣ **Max Pain (最大痛点价):**\n"
    report += f"- 到期日: {expiry_str}\n"
    report += f"- 痛点价: {[float(x) for x in max_pain_prices]}。\n"
    report += f"- 平均: ${avg_max_pain:.2f}，当前: ${current_price:.2f}。\n"
    if current_price > avg_max_pain:
        report += "- 分析: 股价高于痛点，短期或向下修复，偏空信号。\n\n"
    elif current_price < avg_max_pain:
        report += "- 分析: 股价低于痛点，可能向痛点回归，偏多信号。\n\n"
    else:
        report += "- 分析: 股价接近痛点，短期或横盘，信号中性。\n\n"

    # 2️⃣ 钉住概率
    report += "2️⃣ **钉住概率 (Pinning Probability):**\n"
    for e, p in zip(expiries, pinning_probs):
        report += f"- {e}: {p*100:.2f}%\n"
    report += "- 分析: 高概率价位易出现价格钉住，参考该区间布局。\n\n"

    # 3️⃣ Black-Scholes 定价
    report += "3️⃣ **Black-Scholes 定价:**\n"
    report += f"- Call: ${bs_call:.2f}, Put: ${bs_put:.2f}。\n"
    report += "- 分析: 理论价值，若实际溢价显著偏离，可考虑套利策略。\n\n"
    report += f"- BS反推股价(由Call): ${bs_implied_price_call:.2f}, BS反推股价(由Put): ${bs_implied_price_put:.2f}\n\n"

    # 4️⃣ 财报预期区间
    report += "4️⃣ **财报预期区间 (Earnings Move):**\n"
    report += f"- 范围: ${low_move:.2f} - ${high_move:.2f} (±{earnings_move:.2f}%)\n"
    report += "- 分析: 市场约一周内预期波动，区间外为极端情况。\n\n"

    # 5️⃣ 波动率偏斜 & 风险逆转
    report += "5️⃣ **波动率偏斜 & 风险逆转 (Vol Skew & RR):**\n"
    report += f"- Call IV: {call_iv:.2f}%, Put IV: {put_iv:.2f}%, RR: {vol_skew_rr:.2f}%\n"
    if vol_skew_rr > 0:
        report += "- 分析: 正RR，市场偏多，倾向买入看涨期权。\n\n"
    elif vol_skew_rr < 0:
        report += "- 分析: 负RR，市场偏空，倾向买入看跌期权。\n\n"
    else:
        report += "- 分析: RR接近0，中性市场预期。\n\n"

    # 6️⃣ OI & Volume Profile
    report += "6️⃣ **OI & 成交量分布 (Volume Profile):**\n"
    report += f"- Call OI Strike: ${max_call:.2f}, Put OI Strike: ${max_put:.2f}\n"
    report += f"- POC: ${poc:.2f}, VAH: ${vah:.2f}, VAL: ${val:.2f}\n"
    report += f"- 当前价格: ${current_price:.2f}\n"
    if current_price > vah:
        report += "- 分析: 价格超出价值区上沿，短期过热风险。\n\n"
    elif current_price < val:
        report += "- 分析: 价格跌破价值区下沿，短期超卖机会。\n\n"
    else:
        report += "- 分析: 价格在价值区内部，正常波动区间。\n\n"

    # 7️⃣ 综合预测区间
    report += "7️⃣ **综合预测区间 (Forecast Bounds):**\n"
    report += f"- ${forecast_low:.2f} - ${forecast_high:.2f} (至 {(datetime.today()+timedelta(days=forecast_days)).strftime('%Y-%m-%d')})\n"
    report += "- 分析: 结合最大痛点与财报预期，作为短期交易区间。\n\n"
    # 8️⃣ Average Path 分析
    avg_path_end = ( (avg_max_pain + (current_price*(1+vol_skew_rr/200))) / 2 )
    report += "8️⃣ **Average Path (平均路径):**\n"
    report += f"- 预测均值路径价格: ${avg_path_end:.2f}\n"
    if avg_path_end > current_price:
        report += "- 分析: Average Path 高于当前价，市场综合预期偏多，资金博弈与波动率预期均支持反弹。\n\n"
    elif avg_path_end < current_price:
        report += "- 分析: Average Path 低于当前价，综合预期偏空，需防范下行压力。\n\n"
    else:
        report += "- 分析: Average Path 与现价一致，市场预期中性，短期或维持震荡。\n\n"


    # ================= 综合评分与结论 =================
    score = 0

    # Max Pain
    if current_price < avg_max_pain:
        score += 1
    elif current_price > avg_max_pain:
        score -= 1

    # 钉住概率 (仅提示，不计入分数)
    high_pinning = max(pinning_probs)

    # BS反推股价 (Call/Put取平均)
    bs_avg_price = (bs_implied_price_call + bs_implied_price_put) / 2
    if bs_avg_price > current_price:
        score += 1
    elif bs_avg_price < current_price:
        score -= 1

    # RR (风险逆转)
    if vol_skew_rr > 0:
        score += 1
    elif vol_skew_rr < 0:
        score -= 1

    # Volume Profile (POC/VAH/VAL)
    if current_price < val:
        score += 1
    elif current_price > vah:
        score -= 1

    # Average Path
    if avg_path_end > current_price:
        score += 1
    elif avg_path_end < current_price:
        score -= 1

    # 生成综合结论
    report += "📌 **综合结论:**\n"
    if score >= 3:
        report += "- 结论: 市场综合信号 **偏多**，多项指标支持反弹，可在价值区下沿或痛点附近布局多头策略。\n"
    elif score <= -3:
        report += "- 结论: 市场综合信号 **偏空**，期权资金与波动率预期均偏弱，建议采取防御性策略或看跌布局。\n"
    else:
        report += "- 结论: 市场综合信号 **中性/震荡**，Max Pain钉住概率较高或指标分歧，建议观望或区间交易策略。\n"

    # 钉住概率提示
    if high_pinning > 0.2:
        report += f"- 钉住概率提示: 当前最高钉住概率 {high_pinning*100:.2f}% → 价格可能受压于钉住水平，短期震荡概率较高。\n"

    return report

# ================= Run Analysis =================
if st.sidebar.button("Run Analysis"):
    hist = stock.history(period='1d')
    if hist.empty:
        st.error("无历史数据。")
    else:
        current_price = float(hist['Close'].iloc[-1])

        # 获取无风险利率与股息率
        r, q = get_risk_free_and_dividend(ticker)

        # 获取主估值到期日的期权链（用于BS定价和IV分析）
        chain = stock.option_chain(valuation_expiry)
        calls, puts = chain.calls, chain.puts
        max_call = float(calls.loc[calls['openInterest'].idxmax()]['strike'])
        max_put = float(puts.loc[puts['openInterest'].idxmax()]['strike'])

        # Volume Profile
        df = fetch_stock_data(ticker)
        poc, vah, val = compute_volume_profile(df)

        # 初始化列表
        max_pain_prices = []
        pinning_probs = []

        import time
        for expiry in selected_expiries:
            time.sleep(1)  # 防止API限流

            # 获取该到期日的期权链
            chain_exp = stock.option_chain(expiry)
            calls_exp, puts_exp = chain_exp.calls, chain_exp.puts

            # 计算 Max Pain
            pain_price = calculate_max_pain(calls_exp, puts_exp)
            max_pain_prices.append(float(pain_price))

            # 计算钉住概率 (基于 OI 集中度)
            total_oi = calls_exp['openInterest'].sum() + puts_exp['openInterest'].sum()
            step = np.mean(np.diff(sorted(calls_exp['strike'].unique())))
            nearby_range = (pain_price - step, pain_price + step)
            nearby_calls = calls_exp[(calls_exp['strike'] >= nearby_range[0]) & (calls_exp['strike'] <= nearby_range[1])]
            nearby_puts = puts_exp[(puts_exp['strike'] >= nearby_range[0]) & (puts_exp['strike'] <= nearby_range[1])]
            nearby_oi = nearby_calls['openInterest'].sum() + nearby_puts['openInterest'].sum()
            pinning_prob = nearby_oi / total_oi if total_oi > 0 else 0
            pinning_probs.append(pinning_prob)

            print(f"[DEBUG] Expiry: {expiry}, Max Pain: {pain_price:.2f}, Pinning Prob: {pinning_prob:.2%}")

            # 绘制OI分布图
            fig, ax = plt.subplots(figsize=(8,4))
            ax.bar(calls_exp['strike'], calls_exp['openInterest'], color='green', alpha=0.5, label='Calls OI')
            ax.bar(puts_exp['strike'], puts_exp['openInterest'], color='red', alpha=0.5, label='Puts OI')
            ax.axvline(pain_price, color='black', linestyle='--', label='Max Pain')
            ax.set_title(f"OI Distribution & Max Pain ({expiry})")
            ax.set_xlabel("Strike Price")
            ax.set_ylabel("Open Interest")
            ax.legend()
            st.pyplot(fig)

        # 选取平值执行价 (ATM) 和隐含波动率
        atm_strike = min(calls['strike'], key=lambda x: abs(x - current_price))
        atm_iv = float(calls.loc[calls['strike'] == atm_strike, 'impliedVolatility'].iloc[0])
        print(f"[DEBUG] ATM Strike: {atm_strike}, ATM IV: {atm_iv:.2%}")

        # Black-Scholes 定价（使用真实ATM IV）
        bs_call = black_scholes_price(current_price, atm_strike, forecast_days/252, r, q, atm_iv)
        bs_put = black_scholes_price(current_price, atm_strike, forecast_days/252, r, q, atm_iv, 'put')

        # 自动估算财报预期波动 (基于ATM IV)
        earnings_move = atm_iv * np.sqrt(forecast_days / 365) * 100
        # 🧮 BS反推股价 (基于ATM期权市场价格)
        from scipy.optimize import fsolve
        def implied_underlying_price(option_price, K, T, r, q, sigma, option_type='call'):
          def objective(S):
            return black_scholes_price(S, K, T, r, q, sigma, option_type) - option_price
          return fsolve(objective, x0=current_price)[0]
        # 选取ATM执行价对应的市场价格
        atm_call_price = float(calls.loc[calls['strike'] == atm_strike, 'lastPrice'].iloc[0])
        atm_put_price  = float(puts.loc[puts['strike'] == atm_strike, 'lastPrice'].iloc[0])
        # 反推股价
        bs_implied_price_call = implied_underlying_price(atm_call_price, atm_strike, forecast_days/252, r, q, atm_iv, 'call')
        bs_implied_price_put  = implied_underlying_price(atm_put_price, atm_strike, forecast_days/252, r, q, atm_iv, 'put')
        print(f"[DEBUG] BS反推股价(Call): {bs_implied_price_call:.2f}, (Put): {bs_implied_price_put:.2f}")

        # 自动估算财报预期波动 (基于ATM IV)
        earnings_move = atm_iv * np.sqrt(forecast_days / 365) * 100
        # 计算 Call IV、Put IV 与风险逆转 (RR)
        call_iv = float(calls.loc[calls['strike'] == max_call, 'impliedVolatility'].iloc[0]) * 100
        put_iv = float(puts.loc[puts['strike'] == max_put, 'impliedVolatility'].iloc[0]) * 100
        vol_skew_rr = call_iv - put_iv

        # 生成报告
        report = generate_option_report(
            ticker, selected_expiries, max_pain_prices, pinning_probs,
            bs_call, bs_put, earnings_move, vol_skew_rr,
            call_iv, put_iv, current_price,
            poc, vah, val, max_call, max_put,
            forecast_days
        )
        st.markdown(report)

        # 价格预测图
        days = np.arange(0, forecast_days+1)
        avg_max_pain = float(np.mean(max_pain_prices))
        low_move = current_price * (1 - earnings_move/100)
        high_move = current_price * (1 + earnings_move/100)
        forecast_low = min(avg_max_pain, low_move)
        forecast_high = max(avg_max_pain, high_move)
        max_path = np.linspace(current_price, avg_max_pain, len(days))
        bs_path = np.linspace(current_price, current_price*(1+vol_skew_rr/200), len(days))
        avg_path = (max_path + bs_path) / 2

        fig, ax = plt.subplots(figsize=(10, 6))
        ax.plot(days, max_path, label="Max Pain Path")
        ax.plot(days, bs_path, label="BS Path")
        ax.plot(days, avg_path, linestyle='--', label="Average Path")
        ax.hlines([forecast_low, forecast_high], 0, forecast_days, linestyles='dotted', label='Forecast Bounds')
        ax.set_title("Price Anticipation Plot with Bounds")
        ax.set_xlabel("Days")
        ax.set_ylabel("Price")
        ax.legend()
        st.pyplot(fig)





        # ================== 价格预测图 (综合所有路径和区间) ==================
        days = np.arange(0, forecast_days+1)
        avg_max_pain = float(np.mean(max_pain_prices))

        # 财报预期波动区间
        low_move = current_price * (1 - earnings_move/100)
        high_move = current_price * (1 + earnings_move/100)

        # 综合预测区间 (结合Max Pain与财报预期)
        forecast_low = min(avg_max_pain, low_move)
        forecast_high = max(avg_max_pain, high_move)

        # 生成路径
        max_path = np.linspace(current_price, avg_max_pain, len(days))            # Max Pain路径
        bs_path = np.linspace(current_price, current_price*(1+vol_skew_rr/200), len(days))  # BS路径
        avg_path = (max_path + bs_path) / 2                                      # 平均路径

        # 绘制图形
        fig, ax = plt.subplots(figsize=(12, 6))

        # 价格路径
        ax.plot(days, max_path, label="Max Pain Path", color='blue', linewidth=2)
        ax.plot(days, bs_path, label="BS Path", color='green', linewidth=2)
        ax.plot(days, avg_path, linestyle='--', label="Average Path", color='purple', linewidth=2)

        # 当前价格线
        ax.axhline(current_price, color='gray', linestyle=':', linewidth=1.5, label="Current Price")

        # 财报预期区间
        ax.fill_between(days, low_move, high_move, color='orange', alpha=0.15, label="Earnings Move Range")

        # 价值区间 (VAH/VAL)
        ax.fill_between(days, val, vah, color='cyan', alpha=0.1, label="Value Area (VAH/VAL)")

        # 综合预测区间 (Forecast Bounds)
        ax.hlines([forecast_low, forecast_high], 0, forecast_days, linestyles='dotted', colors='red', label='Forecast Bounds')

        # BS反推股价区间 (基于Call/Put)
        ax.axhline(bs_implied_price_call, color='magenta', linestyle='-.', linewidth=1.5, label="BS Implied Price (Call)")
        ax.axhline(bs_implied_price_put, color='brown', linestyle='-.', linewidth=1.5, label="BS Implied Price (Put)")

        # Max Pain价参考线
        ax.axhline(avg_max_pain, color='blue', linestyle='--', linewidth=1, label="Avg Max Pain")

        # 图表美化
        ax.set_title("📈 Comprehensive Price Projection with Max Pain, BS, Earnings, Value Area", fontsize=14)
        ax.set_xlabel("Days Ahead", fontsize=12)
        ax.set_ylabel("Price ($)", fontsize=12)
        ax.legend(loc="upper left", fontsize=10)
        ax.grid(alpha=0.3)

        st.pyplot(fig)




        # ================== 综合价格预测图 + OI曲线 ==================
        fig, ax1 = plt.subplots(figsize=(12, 6))

        # 主轴：价格预测路径
        ax1.plot(days, max_path, label="Max Pain Path", color='blue', linewidth=2)
        ax1.plot(days, bs_path, label="BS Path", color='green', linewidth=2)
        ax1.plot(days, avg_path, linestyle='--', label="Average Path", color='purple', linewidth=2)
        ax1.axhline(current_price, color='gray', linestyle=':', linewidth=1.5, label="Current Price")
        ax1.fill_between(days, low_move, high_move, color='orange', alpha=0.15, label="Earnings Move Range")
        ax1.fill_between(days, val, vah, color='cyan', alpha=0.1, label="Value Area (VAH/VAL)")
        ax1.hlines([forecast_low, forecast_high], 0, forecast_days, linestyles='dotted', colors='red', label='Forecast Bounds')
        ax1.axhline(bs_implied_price_call, color='magenta', linestyle='-.', linewidth=1.5, label="BS Implied Price (Call)")
        ax1.axhline(bs_implied_price_put, color='brown', linestyle='-.', linewidth=1.5, label="BS Implied Price (Put)")
        ax1.axhline(avg_max_pain, color='blue', linestyle='--', linewidth=1, label="Avg Max Pain")
        ax1.set_xlabel("Days Ahead", fontsize=12)
        ax1.set_ylabel("Price ($)", fontsize=12)
        # --- 标注最大OI的价格区间 ---
        ax1.axhline(max_call, color='green', linestyle=':', linewidth=1.5, label=f"Max Call OI Strike (${max_call:.2f})")
        ax1.axhline(max_put, color='red', linestyle=':', linewidth=1.5, label=f"Max Put OI Strike (${max_put:.2f})")

        # 如果要画成区域（区间高亮）
        ax1.fill_between(days, max_put, max_call, color='gray', alpha=0.08, label="Max OI Range (Call-Put)")

        # 次坐标轴：OI 曲线（使用 valuation_expiry 控件）
        ax2 = ax1.twinx()
        expiry_for_oi = valuation_expiry  # 使用用户控件选择的到期日
        chain_exp = stock.option_chain(expiry_for_oi)
        calls_exp, puts_exp = chain_exp.calls, chain_exp.puts
        ax2.plot(calls_exp['strike'], calls_exp['openInterest'], color='green', alpha=0.6, label='Call OI')
        ax2.plot(puts_exp['strike'], puts_exp['openInterest'], color='red', alpha=0.6, label='Put OI')
        ax2.set_ylabel("Open Interest (OI)", fontsize=12)
        ax2.grid(alpha=0.2)

        # 合并图例
        lines1, labels1 = ax1.get_legend_handles_labels()
        lines2, labels2 = ax2.get_legend_handles_labels()
        ax1.legend(lines1 + lines2, labels1 + labels2, loc="upper left", fontsize=10)

        ax1.set_title(f"📈 Price Projection + OI Curve ({expiry_for_oi})", fontsize=14)
        st.pyplot(fig)
# ================== 智能期权策略推荐与盈亏分析 ==================
import numpy as np

def select_optimal_strikes(calls, puts, current_price, max_pain, vah, val):
    strikes = sorted(calls['strike'].unique())
    atm = min(strikes, key=lambda x: abs(x - current_price))
    # 看多腿：靠近Max Pain或ATM
    bullish = (atm, min([s for s in strikes if s > atm], default=atm))
    # 看空腿：低于VAL或ATM
    bearish = (atm, max([s for s in strikes if s < atm], default=atm))
    # 跨式/宽跨
    straddle = (atm, atm)
    strangle = (max([s for s in strikes if s < atm], default=atm-5),
                min([s for s in strikes if s > atm], default=atm+5))
    # 铁鹰：中心设为Max Pain，翼距5
    iron_center = min(strikes, key=lambda x: abs(x - max_pain))
    iron_condor = (iron_center-10, iron_center-5, iron_center+5, iron_center+10)
    return {'bullish': bullish, 'bearish': bearish, 'straddle': straddle, 'strangle': strangle, 'iron_condor': iron_condor}

def calculate_pnl(strategy, price_range):
    pnl = np.zeros_like(price_range)
    for strike, opt_type, pos, premium in strategy:
        if opt_type == 'call':
            intrinsic = np.maximum(price_range - strike, 0)
        else:
            intrinsic = np.maximum(strike - price_range, 0)
        pnl_leg = intrinsic - premium if pos=='long' else premium - intrinsic
        pnl += pnl_leg
    return pnl

# 遍历用户选定的到期日
for expiry in selected_expiries:
    st.subheader(f"策略推荐与盈亏分析: {expiry}")
    chain_exp = stock.option_chain(expiry)
    calls_exp, puts_exp = chain_exp.calls, chain_exp.puts
    pain_price = calculate_max_pain(calls_exp, puts_exp)
    optimal = select_optimal_strikes(calls_exp, puts_exp, current_price, pain_price, vah, val)

    # 构建示例策略：看多价差(Bull Call Spread)
    long_call_price = float(calls_exp.loc[calls_exp['strike']==optimal['bullish'][0],'lastPrice'])
    short_call_price = float(calls_exp.loc[calls_exp['strike']==optimal['bullish'][1],'lastPrice'])
    bull_call_spread = [
        (optimal['bullish'][0], 'call', 'long', long_call_price),
        (optimal['bullish'][1], 'call', 'short', short_call_price)
    ]

    # 计算盈亏
    price_range = np.linspace(current_price*0.8, current_price*1.2, 100)
    pnl = calculate_pnl(bull_call_spread, price_range)

    # 显示策略详情
    st.write(f"**推荐策略: Bull Call Spread** - 买入 {optimal['bullish'][0]}C (${long_call_price:.2f})，卖出 {optimal['bullish'][1]}C (${short_call_price:.2f})")
    st.write(f"最大利润: ${(optimal['bullish'][1]-optimal['bullish'][0])-(long_call_price-short_call_price):.2f} | 最大亏损: ${long_call_price-short_call_price:.2f}")

    # 绘制盈亏图
    fig, ax = plt.subplots(figsize=(8,4))
    ax.plot(price_range, pnl, label="Bull Call Spread")
    ax.axhline(0, color='black', linestyle='--')
    ax.set_title(f"盈亏图: {expiry}")
    ax.set_xlabel("Underlying Price")
    ax.set_ylabel("Profit / Loss")
    ax.legend()
    st.pyplot(fig)
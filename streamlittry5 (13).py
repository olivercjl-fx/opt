# -*- coding: utf-8 -*-
"""streamlittry5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14hvwpG5eq6bbkpVXWxWdLAWe6KoHmDuq
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from scipy.stats import norm
from scipy.optimize import fsolve, curve_fit
# ================= è·å–æ— é£é™©åˆ©ç‡ä¸è‚¡æ¯ç‡ =================
def get_risk_free_and_dividend(ticker):
    # æ— é£é™©åˆ©ç‡ (3M T-Bill)
    tbill = yf.Ticker("^IRX")  # 3ä¸ªæœˆå›½åº“åˆ¸
    r = tbill.history(period="1d")['Close'].iloc[-1] / 100  # è½¬æ¢ä¸ºå°æ•°

    # è‚¡æ¯ç‡ (Dividend Yield)
    stock = yf.Ticker(ticker)
    try:
        div_yield = stock.info.get("dividendYield", 0.0) or 0.0  # è‹¥æ— åˆ†çº¢è¿”å›0
    except:
        div_yield = 0.0
    return r, div_yield
# ================= Streamlit Sidebar Inputs =================
st.sidebar.title("Options Analysis Dashboard")
ticker = st.sidebar.text_input("Ticker", value="AAPL")
expiry_count = st.sidebar.slider("Expiry Count", 1, 10, 3)
forecast_days = st.sidebar.slider("Forecast Days", 10, 90, 30)
E = st.sidebar.slider("E (Pinning)", 0.001, 0.05, 0.01)
opt_type = st.sidebar.selectbox("Option Type", ["Put", "Call"])

# Ensure ticker is valid before fetching data
if ticker:
    stock = yf.Ticker(ticker)
    try:
        expirations = stock.options
        st.sidebar.write("Available Expiries:", expirations)
        selected_expiries = st.sidebar.multiselect(
            "Select Expiries for Analysis", expirations, default=expirations[:expiry_count]
        )
        valuation_expiry = st.sidebar.selectbox("Select Expiry for Valuation", expirations)
    except Exception as e:
        st.error(f"Error fetching options data: {e}")
        selected_expiries, valuation_expiry = [], None
else:
    st.stop()

# ================= Option Strategy Builder =================
st.sidebar.subheader("Option Strategy Builder")
strategy = st.sidebar.selectbox("Select Strategy", ["Single Call", "Single Put", "Vertical Spread", "Straddle"])
strike_price = st.sidebar.number_input("Strike Price", min_value=1.0, value=100.0)
premium = st.sidebar.number_input("Option Premium", min_value=0.0, value=5.0)
if strategy == "Vertical Spread":
    strike_price_2 = st.sidebar.number_input("Second Strike Price", min_value=1.0, value=105.0)
    premium_2 = st.sidebar.number_input("Second Option Premium", min_value=0.0, value=3.0)
if st.sidebar.button("Build Option"):
    price_range = np.linspace(strike_price * 0.8, strike_price * 1.2, 100)
    payoff = None
    if strategy == "Single Call":
        payoff = np.maximum(price_range - strike_price, 0) - premium
    elif strategy == "Single Put":
        payoff = np.maximum(strike_price - price_range, 0) - premium
    elif strategy == "Vertical Spread":
        payoff = (
            np.maximum(price_range - strike_price, 0) - premium
        ) - (
            np.maximum(price_range - strike_price_2, 0) - premium_2
        )
    elif strategy == "Straddle":
        payoff = (
            np.maximum(price_range - strike_price, 0) - premium
        ) + (
            np.maximum(strike_price - price_range, 0) - premium
        )
    fig, ax = plt.subplots(figsize=(8, 4))
    ax.plot(price_range, payoff, label=strategy)
    ax.axhline(0, color='black', linestyle='--')
    ax.set_title(f"Payoff Diagram: {strategy}")
    ax.set_xlabel("Underlying Price")
    ax.set_ylabel("Profit / Loss")
    ax.legend()
    st.pyplot(fig)

# ================= Black-Scholes Pricing =================
def black_scholes_price(S, K, T, r, q, sigma, option_type='call'):
    # q ä¸ºè‚¡æ¯ç‡
    d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    if option_type.lower() == 'call':
        return S * np.exp(-q*T) * norm.cdf(d1) - K * np.exp(-r*T) * norm.cdf(d2)
    return K * np.exp(-r*T) * norm.cdf(-d2) - S * np.exp(-q*T) * norm.cdf(-d1)


# ================= Fetch & Volume Analysis =================
def fetch_stock_data(ticker, period="6mo", interval="1h"):
    df = yf.download(ticker, period=period, interval=interval)
    if df.empty:
        st.warning(f"[é”™è¯¯] æ— æ³•è·å– {ticker} æ•°æ®ã€‚")
        return pd.DataFrame()
    df.reset_index(inplace=True)
    return df

def compute_volume_profile(df, bins=50):
    if df.empty:
        return None, None, None
    hist, edges = np.histogram(df['Close'], bins=bins, weights=df['Volume'])
    poc = float((edges[np.argmax(hist)] + edges[np.argmax(hist) + 1]) / 2)
    total = hist.sum()
    sorted_idx = np.argsort(hist)[::-1]
    cum = np.cumsum(hist[sorted_idx])
    va_idx = sorted_idx[cum <= total * 0.7]
    va_prices = [(edges[i] + edges[i + 1]) / 2 for i in va_idx]
    return poc, float(max(va_prices)), float(min(va_prices))

def calculate_max_pain(calls, puts):
    strikes = sorted(set(calls['strike']).union(set(puts['strike'])))
    pain_list = []
    for strike in strikes:
        call_pain = ((calls['strike'] - strike).clip(lower=0) * calls['openInterest']).sum()
        put_pain = ((strike - puts['strike']).clip(lower=0) * puts['openInterest']).sum()
        pain_list.append(call_pain + put_pain)
    return strikes[np.argmin(pain_list)]


# ================= Generate Detailed Report =================
def generate_option_report(
    ticker, expiries, max_pain_prices, pinning_probs,
    bs_call, bs_put, earnings_move, vol_skew_rr,
    call_iv, put_iv, current_price,
    poc, vah, val, max_call, max_put,
    forecast_days=30
):
    report = f"ğŸ“Š **Option Market Analysis Report: {ticker}**\n\n"
    avg_max_pain = float(np.mean(max_pain_prices))
    expiry_str = ", ".join(expiries)
    low_move = current_price * (1 - earnings_move/100)
    high_move = current_price * (1 + earnings_move/100)
    forecast_low = min(avg_max_pain, low_move)
    forecast_high = max(avg_max_pain, high_move)

    # 1ï¸âƒ£ Max Pain
    report += "1ï¸âƒ£ **Max Pain (æœ€å¤§ç—›ç‚¹ä»·):**\n"
    report += f"- åˆ°æœŸæ—¥: {expiry_str}\n"
    report += f"- ç—›ç‚¹ä»·: {[float(x) for x in max_pain_prices]}ã€‚\n"
    report += f"- å¹³å‡: ${avg_max_pain:.2f}ï¼Œå½“å‰: ${current_price:.2f}ã€‚\n"
    if current_price > avg_max_pain:
        report += "- åˆ†æ: è‚¡ä»·é«˜äºç—›ç‚¹ï¼ŒçŸ­æœŸæˆ–å‘ä¸‹ä¿®å¤ï¼Œåç©ºä¿¡å·ã€‚\n\n"
    elif current_price < avg_max_pain:
        report += "- åˆ†æ: è‚¡ä»·ä½äºç—›ç‚¹ï¼Œå¯èƒ½å‘ç—›ç‚¹å›å½’ï¼Œåå¤šä¿¡å·ã€‚\n\n"
    else:
        report += "- åˆ†æ: è‚¡ä»·æ¥è¿‘ç—›ç‚¹ï¼ŒçŸ­æœŸæˆ–æ¨ªç›˜ï¼Œä¿¡å·ä¸­æ€§ã€‚\n\n"

    # 2ï¸âƒ£ é’‰ä½æ¦‚ç‡
    report += "2ï¸âƒ£ **é’‰ä½æ¦‚ç‡ (Pinning Probability):**\n"
    for e, p in zip(expiries, pinning_probs):
        report += f"- {e}: {p*100:.2f}%\n"
    report += "- åˆ†æ: é«˜æ¦‚ç‡ä»·ä½æ˜“å‡ºç°ä»·æ ¼é’‰ä½ï¼Œå‚è€ƒè¯¥åŒºé—´å¸ƒå±€ã€‚\n\n"

    # 3ï¸âƒ£ Black-Scholes å®šä»·
    report += "3ï¸âƒ£ **Black-Scholes å®šä»·:**\n"
    report += f"- Call: ${bs_call:.2f}, Put: ${bs_put:.2f}ã€‚\n"
    report += "- åˆ†æ: ç†è®ºä»·å€¼ï¼Œè‹¥å®é™…æº¢ä»·æ˜¾è‘—åç¦»ï¼Œå¯è€ƒè™‘å¥—åˆ©ç­–ç•¥ã€‚\n\n"
    report += f"- BSåæ¨è‚¡ä»·(ç”±Call): ${bs_implied_price_call:.2f}, BSåæ¨è‚¡ä»·(ç”±Put): ${bs_implied_price_put:.2f}\n\n"

    # 4ï¸âƒ£ è´¢æŠ¥é¢„æœŸåŒºé—´
    report += "4ï¸âƒ£ **è´¢æŠ¥é¢„æœŸåŒºé—´ (Earnings Move):**\n"
    report += f"- èŒƒå›´: ${low_move:.2f} - ${high_move:.2f} (Â±{earnings_move:.2f}%)\n"
    report += "- åˆ†æ: å¸‚åœºçº¦ä¸€å‘¨å†…é¢„æœŸæ³¢åŠ¨ï¼ŒåŒºé—´å¤–ä¸ºæç«¯æƒ…å†µã€‚\n\n"

    # 5ï¸âƒ£ æ³¢åŠ¨ç‡åæ–œ & é£é™©é€†è½¬
    report += "5ï¸âƒ£ **æ³¢åŠ¨ç‡åæ–œ & é£é™©é€†è½¬ (Vol Skew & RR):**\n"
    report += f"- Call IV: {call_iv:.2f}%, Put IV: {put_iv:.2f}%, RR: {vol_skew_rr:.2f}%\n"
    if vol_skew_rr > 0:
        report += "- åˆ†æ: æ­£RRï¼Œå¸‚åœºåå¤šï¼Œå€¾å‘ä¹°å…¥çœ‹æ¶¨æœŸæƒã€‚\n\n"
    elif vol_skew_rr < 0:
        report += "- åˆ†æ: è´ŸRRï¼Œå¸‚åœºåç©ºï¼Œå€¾å‘ä¹°å…¥çœ‹è·ŒæœŸæƒã€‚\n\n"
    else:
        report += "- åˆ†æ: RRæ¥è¿‘0ï¼Œä¸­æ€§å¸‚åœºé¢„æœŸã€‚\n\n"

    # 6ï¸âƒ£ OI & Volume Profile
    report += "6ï¸âƒ£ **OI & æˆäº¤é‡åˆ†å¸ƒ (Volume Profile):**\n"
    report += f"- Call OI Strike: ${max_call:.2f}, Put OI Strike: ${max_put:.2f}\n"
    report += f"- POC: ${poc:.2f}, VAH: ${vah:.2f}, VAL: ${val:.2f}\n"
    report += f"- å½“å‰ä»·æ ¼: ${current_price:.2f}\n"
    if current_price > vah:
        report += "- åˆ†æ: ä»·æ ¼è¶…å‡ºä»·å€¼åŒºä¸Šæ²¿ï¼ŒçŸ­æœŸè¿‡çƒ­é£é™©ã€‚\n\n"
    elif current_price < val:
        report += "- åˆ†æ: ä»·æ ¼è·Œç ´ä»·å€¼åŒºä¸‹æ²¿ï¼ŒçŸ­æœŸè¶…å–æœºä¼šã€‚\n\n"
    else:
        report += "- åˆ†æ: ä»·æ ¼åœ¨ä»·å€¼åŒºå†…éƒ¨ï¼Œæ­£å¸¸æ³¢åŠ¨åŒºé—´ã€‚\n\n"

    # 7ï¸âƒ£ ç»¼åˆé¢„æµ‹åŒºé—´
    report += "7ï¸âƒ£ **ç»¼åˆé¢„æµ‹åŒºé—´ (Forecast Bounds):**\n"
    report += f"- ${forecast_low:.2f} - ${forecast_high:.2f} (è‡³ {(datetime.today()+timedelta(days=forecast_days)).strftime('%Y-%m-%d')})\n"
    report += "- åˆ†æ: ç»“åˆæœ€å¤§ç—›ç‚¹ä¸è´¢æŠ¥é¢„æœŸï¼Œä½œä¸ºçŸ­æœŸäº¤æ˜“åŒºé—´ã€‚\n\n"
    # 8ï¸âƒ£ Average Path åˆ†æ
    avg_path_end = ( (avg_max_pain + (current_price*(1+vol_skew_rr/200))) / 2 )
    report += "8ï¸âƒ£ **Average Path (å¹³å‡è·¯å¾„):**\n"
    report += f"- é¢„æµ‹å‡å€¼è·¯å¾„ä»·æ ¼: ${avg_path_end:.2f}\n"
    if avg_path_end > current_price:
        report += "- åˆ†æ: Average Path é«˜äºå½“å‰ä»·ï¼Œå¸‚åœºç»¼åˆé¢„æœŸåå¤šï¼Œèµ„é‡‘åšå¼ˆä¸æ³¢åŠ¨ç‡é¢„æœŸå‡æ”¯æŒåå¼¹ã€‚\n\n"
    elif avg_path_end < current_price:
        report += "- åˆ†æ: Average Path ä½äºå½“å‰ä»·ï¼Œç»¼åˆé¢„æœŸåç©ºï¼Œéœ€é˜²èŒƒä¸‹è¡Œå‹åŠ›ã€‚\n\n"
    else:
        report += "- åˆ†æ: Average Path ä¸ç°ä»·ä¸€è‡´ï¼Œå¸‚åœºé¢„æœŸä¸­æ€§ï¼ŒçŸ­æœŸæˆ–ç»´æŒéœ‡è¡ã€‚\n\n"


    # ================= ç»¼åˆè¯„åˆ†ä¸ç»“è®º =================
    score = 0

    # Max Pain
    if current_price < avg_max_pain:
        score += 1
    elif current_price > avg_max_pain:
        score -= 1

    # é’‰ä½æ¦‚ç‡ (ä»…æç¤ºï¼Œä¸è®¡å…¥åˆ†æ•°)
    high_pinning = max(pinning_probs)

    # BSåæ¨è‚¡ä»· (Call/Putå–å¹³å‡)
    bs_avg_price = (bs_implied_price_call + bs_implied_price_put) / 2
    if bs_avg_price > current_price:
        score += 1
    elif bs_avg_price < current_price:
        score -= 1

    # RR (é£é™©é€†è½¬)
    if vol_skew_rr > 0:
        score += 1
    elif vol_skew_rr < 0:
        score -= 1

    # Volume Profile (POC/VAH/VAL)
    if current_price < val:
        score += 1
    elif current_price > vah:
        score -= 1

    # Average Path
    if avg_path_end > current_price:
        score += 1
    elif avg_path_end < current_price:
        score -= 1

    # ç”Ÿæˆç»¼åˆç»“è®º
    report += "ğŸ“Œ **ç»¼åˆç»“è®º:**\n"
    if score >= 3:
        report += "- ç»“è®º: å¸‚åœºç»¼åˆä¿¡å· **åå¤š**ï¼Œå¤šé¡¹æŒ‡æ ‡æ”¯æŒåå¼¹ï¼Œå¯åœ¨ä»·å€¼åŒºä¸‹æ²¿æˆ–ç—›ç‚¹é™„è¿‘å¸ƒå±€å¤šå¤´ç­–ç•¥ã€‚\n"
    elif score <= -3:
        report += "- ç»“è®º: å¸‚åœºç»¼åˆä¿¡å· **åç©º**ï¼ŒæœŸæƒèµ„é‡‘ä¸æ³¢åŠ¨ç‡é¢„æœŸå‡åå¼±ï¼Œå»ºè®®é‡‡å–é˜²å¾¡æ€§ç­–ç•¥æˆ–çœ‹è·Œå¸ƒå±€ã€‚\n"
    else:
        report += "- ç»“è®º: å¸‚åœºç»¼åˆä¿¡å· **ä¸­æ€§/éœ‡è¡**ï¼ŒMax Painé’‰ä½æ¦‚ç‡è¾ƒé«˜æˆ–æŒ‡æ ‡åˆ†æ­§ï¼Œå»ºè®®è§‚æœ›æˆ–åŒºé—´äº¤æ˜“ç­–ç•¥ã€‚\n"

    # é’‰ä½æ¦‚ç‡æç¤º
    if high_pinning > 0.2:
        report += f"- é’‰ä½æ¦‚ç‡æç¤º: å½“å‰æœ€é«˜é’‰ä½æ¦‚ç‡ {high_pinning*100:.2f}% â†’ ä»·æ ¼å¯èƒ½å—å‹äºé’‰ä½æ°´å¹³ï¼ŒçŸ­æœŸéœ‡è¡æ¦‚ç‡è¾ƒé«˜ã€‚\n"

    return report

# ================= Run Analysis =================
if st.sidebar.button("Run Analysis"):
    hist = stock.history(period='1d')
    if hist.empty:
        st.error("æ— å†å²æ•°æ®ã€‚")
    else:
        current_price = float(hist['Close'].iloc[-1])

        # è·å–æ— é£é™©åˆ©ç‡ä¸è‚¡æ¯ç‡
        r, q = get_risk_free_and_dividend(ticker)

        # è·å–ä¸»ä¼°å€¼åˆ°æœŸæ—¥çš„æœŸæƒé“¾ï¼ˆç”¨äºBSå®šä»·å’ŒIVåˆ†æï¼‰
        chain = stock.option_chain(valuation_expiry)
        calls, puts = chain.calls, chain.puts
        max_call = float(calls.loc[calls['openInterest'].idxmax()]['strike'])
        max_put = float(puts.loc[puts['openInterest'].idxmax()]['strike'])

        # Volume Profile
        df = fetch_stock_data(ticker)
        poc, vah, val = compute_volume_profile(df)

        # åˆå§‹åŒ–åˆ—è¡¨
        max_pain_prices = []
        pinning_probs = []

        import time
        for expiry in selected_expiries:
            time.sleep(1)  # é˜²æ­¢APIé™æµ

            # è·å–è¯¥åˆ°æœŸæ—¥çš„æœŸæƒé“¾
            chain_exp = stock.option_chain(expiry)
            calls_exp, puts_exp = chain_exp.calls, chain_exp.puts

            # è®¡ç®— Max Pain
            pain_price = calculate_max_pain(calls_exp, puts_exp)
            max_pain_prices.append(float(pain_price))

            # è®¡ç®—é’‰ä½æ¦‚ç‡ (åŸºäº OI é›†ä¸­åº¦)
            total_oi = calls_exp['openInterest'].sum() + puts_exp['openInterest'].sum()
            step = np.mean(np.diff(sorted(calls_exp['strike'].unique())))
            nearby_range = (pain_price - step, pain_price + step)
            nearby_calls = calls_exp[(calls_exp['strike'] >= nearby_range[0]) & (calls_exp['strike'] <= nearby_range[1])]
            nearby_puts = puts_exp[(puts_exp['strike'] >= nearby_range[0]) & (puts_exp['strike'] <= nearby_range[1])]
            nearby_oi = nearby_calls['openInterest'].sum() + nearby_puts['openInterest'].sum()
            pinning_prob = nearby_oi / total_oi if total_oi > 0 else 0
            pinning_probs.append(pinning_prob)

            print(f"[DEBUG] Expiry: {expiry}, Max Pain: {pain_price:.2f}, Pinning Prob: {pinning_prob:.2%}")

            # ç»˜åˆ¶OIåˆ†å¸ƒå›¾
            fig, ax = plt.subplots(figsize=(8,4))
            ax.bar(calls_exp['strike'], calls_exp['openInterest'], color='green', alpha=0.5, label='Calls OI')
            ax.bar(puts_exp['strike'], puts_exp['openInterest'], color='red', alpha=0.5, label='Puts OI')
            ax.axvline(pain_price, color='black', linestyle='--', label='Max Pain')
            ax.set_title(f"OI Distribution & Max Pain ({expiry})")
            ax.set_xlabel("Strike Price")
            ax.set_ylabel("Open Interest")
            ax.legend()
            st.pyplot(fig)

        # é€‰å–å¹³å€¼æ‰§è¡Œä»· (ATM) å’Œéšå«æ³¢åŠ¨ç‡
        atm_strike = min(calls['strike'], key=lambda x: abs(x - current_price))
        atm_iv = float(calls.loc[calls['strike'] == atm_strike, 'impliedVolatility'].iloc[0])
        print(f"[DEBUG] ATM Strike: {atm_strike}, ATM IV: {atm_iv:.2%}")

        # Black-Scholes å®šä»·ï¼ˆä½¿ç”¨çœŸå®ATM IVï¼‰
        bs_call = black_scholes_price(current_price, atm_strike, forecast_days/252, r, q, atm_iv)
        bs_put = black_scholes_price(current_price, atm_strike, forecast_days/252, r, q, atm_iv, 'put')

        # è‡ªåŠ¨ä¼°ç®—è´¢æŠ¥é¢„æœŸæ³¢åŠ¨ (åŸºäºATM IV)
        earnings_move = atm_iv * np.sqrt(forecast_days / 365) * 100
        # ğŸ§® BSåæ¨è‚¡ä»· (åŸºäºATMæœŸæƒå¸‚åœºä»·æ ¼)
        from scipy.optimize import fsolve
        def implied_underlying_price(option_price, K, T, r, q, sigma, option_type='call'):
          def objective(S):
            return black_scholes_price(S, K, T, r, q, sigma, option_type) - option_price
          return fsolve(objective, x0=current_price)[0]
        # é€‰å–ATMæ‰§è¡Œä»·å¯¹åº”çš„å¸‚åœºä»·æ ¼
        atm_call_price = float(calls.loc[calls['strike'] == atm_strike, 'lastPrice'].iloc[0])
        atm_put_price  = float(puts.loc[puts['strike'] == atm_strike, 'lastPrice'].iloc[0])
        # åæ¨è‚¡ä»·
        bs_implied_price_call = implied_underlying_price(atm_call_price, atm_strike, forecast_days/252, r, q, atm_iv, 'call')
        bs_implied_price_put  = implied_underlying_price(atm_put_price, atm_strike, forecast_days/252, r, q, atm_iv, 'put')
        print(f"[DEBUG] BSåæ¨è‚¡ä»·(Call): {bs_implied_price_call:.2f}, (Put): {bs_implied_price_put:.2f}")

        # è‡ªåŠ¨ä¼°ç®—è´¢æŠ¥é¢„æœŸæ³¢åŠ¨ (åŸºäºATM IV)
        earnings_move = atm_iv * np.sqrt(forecast_days / 365) * 100
        # è®¡ç®— Call IVã€Put IV ä¸é£é™©é€†è½¬ (RR)
        call_iv = float(calls.loc[calls['strike'] == max_call, 'impliedVolatility'].iloc[0]) * 100
        put_iv = float(puts.loc[puts['strike'] == max_put, 'impliedVolatility'].iloc[0]) * 100
        vol_skew_rr = call_iv - put_iv

        # ç”ŸæˆæŠ¥å‘Š
        report = generate_option_report(
            ticker, selected_expiries, max_pain_prices, pinning_probs,
            bs_call, bs_put, earnings_move, vol_skew_rr,
            call_iv, put_iv, current_price,
            poc, vah, val, max_call, max_put,
            forecast_days
        )
        st.markdown(report)

        # ä»·æ ¼é¢„æµ‹å›¾
        days = np.arange(0, forecast_days+1)
        avg_max_pain = float(np.mean(max_pain_prices))
        low_move = current_price * (1 - earnings_move/100)
        high_move = current_price * (1 + earnings_move/100)
        forecast_low = min(avg_max_pain, low_move)
        forecast_high = max(avg_max_pain, high_move)
        max_path = np.linspace(current_price, avg_max_pain, len(days))
        bs_path = np.linspace(current_price, current_price*(1+vol_skew_rr/200), len(days))
        avg_path = (max_path + bs_path) / 2

        fig, ax = plt.subplots(figsize=(10, 6))
        ax.plot(days, max_path, label="Max Pain Path")
        ax.plot(days, bs_path, label="BS Path")
        ax.plot(days, avg_path, linestyle='--', label="Average Path")
        ax.hlines([forecast_low, forecast_high], 0, forecast_days, linestyles='dotted', label='Forecast Bounds')
        ax.set_title("Price Anticipation Plot with Bounds")
        ax.set_xlabel("Days")
        ax.set_ylabel("Price")
        ax.legend()
        st.pyplot(fig)





        # ================== ä»·æ ¼é¢„æµ‹å›¾ (ç»¼åˆæ‰€æœ‰è·¯å¾„å’ŒåŒºé—´) ==================
        days = np.arange(0, forecast_days+1)
        avg_max_pain = float(np.mean(max_pain_prices))

        # è´¢æŠ¥é¢„æœŸæ³¢åŠ¨åŒºé—´
        low_move = current_price * (1 - earnings_move/100)
        high_move = current_price * (1 + earnings_move/100)

        # ç»¼åˆé¢„æµ‹åŒºé—´ (ç»“åˆMax Painä¸è´¢æŠ¥é¢„æœŸ)
        forecast_low = min(avg_max_pain, low_move)
        forecast_high = max(avg_max_pain, high_move)

        # ç”Ÿæˆè·¯å¾„
        max_path = np.linspace(current_price, avg_max_pain, len(days))            # Max Painè·¯å¾„
        bs_path = np.linspace(current_price, current_price*(1+vol_skew_rr/200), len(days))  # BSè·¯å¾„
        avg_path = (max_path + bs_path) / 2                                      # å¹³å‡è·¯å¾„

        # ç»˜åˆ¶å›¾å½¢
        fig, ax = plt.subplots(figsize=(12, 6))

        # ä»·æ ¼è·¯å¾„
        ax.plot(days, max_path, label="Max Pain Path", color='blue', linewidth=2)
        ax.plot(days, bs_path, label="BS Path", color='green', linewidth=2)
        ax.plot(days, avg_path, linestyle='--', label="Average Path", color='purple', linewidth=2)

        # å½“å‰ä»·æ ¼çº¿
        ax.axhline(current_price, color='gray', linestyle=':', linewidth=1.5, label="Current Price")

        # è´¢æŠ¥é¢„æœŸåŒºé—´
        ax.fill_between(days, low_move, high_move, color='orange', alpha=0.15, label="Earnings Move Range")

        # ä»·å€¼åŒºé—´ (VAH/VAL)
        ax.fill_between(days, val, vah, color='cyan', alpha=0.1, label="Value Area (VAH/VAL)")

        # ç»¼åˆé¢„æµ‹åŒºé—´ (Forecast Bounds)
        ax.hlines([forecast_low, forecast_high], 0, forecast_days, linestyles='dotted', colors='red', label='Forecast Bounds')

        # BSåæ¨è‚¡ä»·åŒºé—´ (åŸºäºCall/Put)
        ax.axhline(bs_implied_price_call, color='magenta', linestyle='-.', linewidth=1.5, label="BS Implied Price (Call)")
        ax.axhline(bs_implied_price_put, color='brown', linestyle='-.', linewidth=1.5, label="BS Implied Price (Put)")

        # Max Painä»·å‚è€ƒçº¿
        ax.axhline(avg_max_pain, color='blue', linestyle='--', linewidth=1, label="Avg Max Pain")

        # å›¾è¡¨ç¾åŒ–
        ax.set_title("ğŸ“ˆ Comprehensive Price Projection with Max Pain, BS, Earnings, Value Area", fontsize=14)
        ax.set_xlabel("Days Ahead", fontsize=12)
        ax.set_ylabel("Price ($)", fontsize=12)
        ax.legend(loc="upper left", fontsize=10)
        ax.grid(alpha=0.3)

        st.pyplot(fig)




        # ================== ç»¼åˆä»·æ ¼é¢„æµ‹å›¾ + OIæ›²çº¿ ==================
        fig, ax1 = plt.subplots(figsize=(12, 6))

        # ä¸»è½´ï¼šä»·æ ¼é¢„æµ‹è·¯å¾„
        ax1.plot(days, max_path, label="Max Pain Path", color='blue', linewidth=2)
        ax1.plot(days, bs_path, label="BS Path", color='green', linewidth=2)
        ax1.plot(days, avg_path, linestyle='--', label="Average Path", color='purple', linewidth=2)
        ax1.axhline(current_price, color='gray', linestyle=':', linewidth=1.5, label="Current Price")
        ax1.fill_between(days, low_move, high_move, color='orange', alpha=0.15, label="Earnings Move Range")
        ax1.fill_between(days, val, vah, color='cyan', alpha=0.1, label="Value Area (VAH/VAL)")
        ax1.hlines([forecast_low, forecast_high], 0, forecast_days, linestyles='dotted', colors='red', label='Forecast Bounds')
        ax1.axhline(bs_implied_price_call, color='magenta', linestyle='-.', linewidth=1.5, label="BS Implied Price (Call)")
        ax1.axhline(bs_implied_price_put, color='brown', linestyle='-.', linewidth=1.5, label="BS Implied Price (Put)")
        ax1.axhline(avg_max_pain, color='blue', linestyle='--', linewidth=1, label="Avg Max Pain")
        ax1.set_xlabel("Days Ahead", fontsize=12)
        ax1.set_ylabel("Price ($)", fontsize=12)
        # --- æ ‡æ³¨æœ€å¤§OIçš„ä»·æ ¼åŒºé—´ ---
        ax1.axhline(max_call, color='green', linestyle=':', linewidth=1.5, label=f"Max Call OI Strike (${max_call:.2f})")
        ax1.axhline(max_put, color='red', linestyle=':', linewidth=1.5, label=f"Max Put OI Strike (${max_put:.2f})")

        # å¦‚æœè¦ç”»æˆåŒºåŸŸï¼ˆåŒºé—´é«˜äº®ï¼‰
        ax1.fill_between(days, max_put, max_call, color='gray', alpha=0.08, label="Max OI Range (Call-Put)")

        # æ¬¡åæ ‡è½´ï¼šOI æ›²çº¿ï¼ˆä½¿ç”¨ valuation_expiry æ§ä»¶ï¼‰
        ax2 = ax1.twinx()
        expiry_for_oi = valuation_expiry  # ä½¿ç”¨ç”¨æˆ·æ§ä»¶é€‰æ‹©çš„åˆ°æœŸæ—¥
        chain_exp = stock.option_chain(expiry_for_oi)
        calls_exp, puts_exp = chain_exp.calls, chain_exp.puts
        ax2.plot(calls_exp['strike'], calls_exp['openInterest'], color='green', alpha=0.6, label='Call OI')
        ax2.plot(puts_exp['strike'], puts_exp['openInterest'], color='red', alpha=0.6, label='Put OI')
        ax2.set_ylabel("Open Interest (OI)", fontsize=12)
        ax2.grid(alpha=0.2)

        # åˆå¹¶å›¾ä¾‹
        lines1, labels1 = ax1.get_legend_handles_labels()
        lines2, labels2 = ax2.get_legend_handles_labels()
        ax1.legend(lines1 + lines2, labels1 + labels2, loc="upper left", fontsize=10)

        ax1.set_title(f"ğŸ“ˆ Price Projection + OI Curve ({expiry_for_oi})", fontsize=14)
        st.pyplot(fig)
# ================== æ™ºèƒ½æœŸæƒç­–ç•¥æ¨èä¸ç›ˆäºåˆ†æ ==================
import numpy as np

def select_optimal_strikes(calls, puts, current_price, max_pain, vah, val):
    strikes = sorted(calls['strike'].unique())
    atm = min(strikes, key=lambda x: abs(x - current_price))
    # çœ‹å¤šè…¿ï¼šé è¿‘Max Painæˆ–ATM
    bullish = (atm, min([s for s in strikes if s > atm], default=atm))
    # çœ‹ç©ºè…¿ï¼šä½äºVALæˆ–ATM
    bearish = (atm, max([s for s in strikes if s < atm], default=atm))
    # è·¨å¼/å®½è·¨
    straddle = (atm, atm)
    strangle = (max([s for s in strikes if s < atm], default=atm-5),
                min([s for s in strikes if s > atm], default=atm+5))
    # é“é¹°ï¼šä¸­å¿ƒè®¾ä¸ºMax Painï¼Œç¿¼è·5
    iron_center = min(strikes, key=lambda x: abs(x - max_pain))
    iron_condor = (iron_center-10, iron_center-5, iron_center+5, iron_center+10)
    return {'bullish': bullish, 'bearish': bearish, 'straddle': straddle, 'strangle': strangle, 'iron_condor': iron_condor}

def calculate_pnl(strategy, price_range):
    pnl = np.zeros_like(price_range)
    for strike, opt_type, pos, premium in strategy:
        if opt_type == 'call':
            intrinsic = np.maximum(price_range - strike, 0)
        else:
            intrinsic = np.maximum(strike - price_range, 0)
        pnl_leg = intrinsic - premium if pos=='long' else premium - intrinsic
        pnl += pnl_leg
    return pnl

# éå†ç”¨æˆ·é€‰å®šçš„åˆ°æœŸæ—¥
for expiry in selected_expiries:
    st.subheader(f"ç­–ç•¥æ¨èä¸ç›ˆäºåˆ†æ: {expiry}")
    chain_exp = stock.option_chain(expiry)
    calls_exp, puts_exp = chain_exp.calls, chain_exp.puts
    pain_price = calculate_max_pain(calls_exp, puts_exp)
    optimal = select_optimal_strikes(calls_exp, puts_exp, current_price, pain_price, vah, val)

    # æ„å»ºç¤ºä¾‹ç­–ç•¥ï¼šçœ‹å¤šä»·å·®(Bull Call Spread)
    long_call_price = float(calls_exp.loc[calls_exp['strike']==optimal['bullish'][0],'lastPrice'])
    short_call_price = float(calls_exp.loc[calls_exp['strike']==optimal['bullish'][1],'lastPrice'])
    bull_call_spread = [
        (optimal['bullish'][0], 'call', 'long', long_call_price),
        (optimal['bullish'][1], 'call', 'short', short_call_price)
    ]

    # è®¡ç®—ç›ˆäº
    price_range = np.linspace(current_price*0.8, current_price*1.2, 100)
    pnl = calculate_pnl(bull_call_spread, price_range)

    # æ˜¾ç¤ºç­–ç•¥è¯¦æƒ…
    st.write(f"**æ¨èç­–ç•¥: Bull Call Spread** - ä¹°å…¥ {optimal['bullish'][0]}C (${long_call_price:.2f})ï¼Œå–å‡º {optimal['bullish'][1]}C (${short_call_price:.2f})")
    st.write(f"æœ€å¤§åˆ©æ¶¦: ${(optimal['bullish'][1]-optimal['bullish'][0])-(long_call_price-short_call_price):.2f} | æœ€å¤§äºæŸ: ${long_call_price-short_call_price:.2f}")

    # ç»˜åˆ¶ç›ˆäºå›¾
    fig, ax = plt.subplots(figsize=(8,4))
    ax.plot(price_range, pnl, label="Bull Call Spread")
    ax.axhline(0, color='black', linestyle='--')
    ax.set_title(f"ç›ˆäºå›¾: {expiry}")
    ax.set_xlabel("Underlying Price")
    ax.set_ylabel("Profit / Loss")
    ax.legend()
    st.pyplot(fig)
# -*- coding: utf-8 -*-
"""streamlittry5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14hvwpG5eq6bbkpVXWxWdLAWe6KoHmDuq
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from scipy.stats import norm
from scipy.optimize import fsolve
from yfinance.exceptions import YFRateLimitError

# ================= Streamlit Sidebar Inputs =================
st.sidebar.title("Options Analysis Dashboard")
ticker = st.sidebar.text_input("Ticker", value="AAPL")
expiry_count = st.sidebar.slider("Expiry Count", 1, 10, 3)
forecast_days = st.sidebar.slider("Forecast Days", 10, 90, 30)

# ================= Black-Scholes Pricing =================
def black_scholes_price(S, K, T, r, sigma, option_type='call'):
    """Compute Black-Scholes option price."""
    if T <= 0 or sigma <= 0 or S <= 0:
        return 0.0
    d1 = (np.log(S/K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    if option_type == 'call':
        return S * norm.cdf(d1) - K * np.exp(-r*T) * norm.cdf(d2)
    else:
        return K * np.exp(-r*T) * norm.cdf(-d2) - S * norm.cdf(-d1)

# ================= Implied Stock Price =================
def implied_stock_price(option_price, K, T, r, sigma, option_type='call'):
    """Invert Black-Scholes to approximate underlying stock price."""
    # Objective: find S such that BS_price(S) - option_price = 0
    func = lambda S: black_scholes_price(S, K, T, r, sigma, option_type) - option_price
    # initial guess: assume option_price + K*exp(-rT)
    S0 = option_price + K * np.exp(-r*T)
    try:
        S_est = fsolve(func, S0)[0]
        return float(S_est)
    except Exception:
        return np.nan

# ================= Data Fetch =================
def fetch_data(ticker):
    """Fetch current price and historical intraday data with rate limit handling."""
    try:
        hist = yf.Ticker(ticker).history(period='1d')
        df = yf.download(ticker, period='6mo', interval='1h')
    except YFRateLimitError:
        st.error("Yahoo Finance rate limit reached. Please try again later.")
        return None, None
    except Exception as e:
        st.error(f"Error fetching data: {e}")
        return None, None
    return hist, df

# ================= Volume Profile =================
def compute_volume_profile(df, bins=50):
    if df is None or df.empty:
        return np.nan, np.nan, np.nan
    hist, edges = np.histogram(df['Close'], bins=bins, weights=df['Volume'])
    poc = (edges[np.argmax(hist)] + edges[np.argmax(hist)+1]) / 2
    total = hist.sum()
    sorted_idx = np.argsort(hist)[::-1]
    cum = np.cumsum(hist[sorted_idx])
    va_idx = sorted_idx[cum <= total * 0.7]
    prices = [(edges[i] + edges[i+1]) / 2 for i in va_idx]
    return float(poc), float(max(prices)), float(min(prices))

# ================= Stock Rating =================
def compute_stock_rating(current_price, avg_max_pain, vol_skew_rr, poc, vah, val):
    dp = max(0, 1 - abs(current_price - avg_max_pain) / avg_max_pain)
    ds = (vol_skew_rr + 100) / 200
    dv = max(0, 1 - abs(current_price - poc) / (vah - val)) if vah != val else 0
    score = np.clip((0.4*dp + 0.3*ds + 0.3*dv) * 10, 0, 10)
    return round(score, 1)

# ================= UI: Implied Price Calculator =================
st.sidebar.subheader("Implied Stock Price Calculator")
opt_type_imp = st.sidebar.selectbox("Option Type for Implied Price", ["Call", "Put"])
K_imp = st.sidebar.number_input("Strike Price (K)", min_value=0.1, value=100.0)
r_imp = st.sidebar.number_input("Risk-free Rate (r)", min_value=0.0, value=0.03)
sigma_imp = st.sidebar.number_input("Volatility (sigma)", min_value=0.01, max_value=1.0, value=0.2)
price_imp = st.sidebar.number_input("Market Option Price", min_value=0.0, value=5.0)
T_imp = st.sidebar.slider("Time to Expiry (days)", 1, 365, 30) / 252
if st.sidebar.button("Calculate Implied Price"):
    side = 'call' if opt_type_imp == 'Call' else 'put'
    S_imp = implied_stock_price(price_imp, K_imp, T_imp, r_imp, sigma_imp, side)
    if not np.isnan(S_imp):
        st.sidebar.write(f"‚Üí Implied Stock Price: ${S_imp:.2f}")
    else:
        st.sidebar.error("Unable to compute implied price. Check inputs.")

# ================= Report Generation =================
def generate_reports(
    ticker, expiries, max_pain_prices, pin_probs,
    bs_call, bs_put, earnings_move, vol_skew_rr,
    call_iv, put_iv, current_price,
    poc, vah, val, max_call, max_put,
    forecast_days
):
    avg_max_pain = np.mean(max_pain_prices)
    low_move = current_price * (1 - earnings_move/100)
    high_move = current_price * (1 + earnings_move/100)
    forecast_low = min(avg_max_pain, low_move)
    forecast_high = max(avg_max_pain, high_move)

    # Chinese report
    cn = [f"üìä ÊúüÊùÉÂ∏ÇÂú∫ÂàÜÊûêÊä•Âëä: {ticker}", f"ÂΩìÂâçËÇ°‰ª∑: ${current_price:.2f}"]
    sentiment = 'ÂÅèÁ©∫' if current_price > avg_max_pain else 'ÂÅèÂ§ö' if current_price < avg_max_pain else '‰∏≠ÊÄß'
    cn.append(f"1Ô∏è‚É£ Max Pain Âπ≥Âùá: ${avg_max_pain:.2f} (ÂΩìÂâç ${current_price:.2f}) -> {sentiment}")
    cn.append(f"2Ô∏è‚É£ Èíâ‰ΩèÊ¶ÇÁéá: {[(e, round(p*100,2)) for e,p in zip(expiries,pin_probs)]} (ÂΩìÂâç ${current_price:.2f})")
    cn.append(f"3Ô∏è‚É£ BS ÂÆö‰ª∑: Call${bs_call:.2f}, Put${bs_put:.2f} (ÂΩìÂâç ${current_price:.2f})")
    cn.append(f"4Ô∏è‚É£ Ë¥¢Êä•È¢ÑÊúüÂå∫Èó¥: ${low_move:.2f} - ${high_move:.2f} (ÂΩìÂâç ${current_price:.2f})")
    cn.append(f"5Ô∏è‚É£ Ê≥¢Âä®ÁéáÂÅèÊñú(RR): {vol_skew_rr:.2f}% (ÂΩìÂâç ${current_price:.2f})")
    cn.append(f"6Ô∏è‚É£ OI ÊâßË°å‰ª∑: Call${max_call:.2f}, Put${max_put:.2f}; Êàê‰∫§ÈáèÂàÜÂ∏É POC${poc:.2f}-VAH${vah:.2f}-VAL${val:.2f} (ÂΩìÂâç ${current_price:.2f})")
    cn.append(f"7Ô∏è‚É£ ÁªºÂêàÈ¢ÑÊµãÂå∫Èó¥: ${forecast_low:.2f} - ${forecast_high:.2f} (ÂΩìÂâç ${current_price:.2f})")
    score = compute_stock_rating(current_price, avg_max_pain, vol_skew_rr, poc, vah, val)
    cn.append(f"üìà ËÇ°Á•®ËØÑÂàÜ (0-10): {score}")

    # English report
    en = [f"üìä Option Market Analysis Report: {ticker}", f"Current Price: ${current_price:.2f}"]
    sentiment_en = 'Bearish' if current_price > avg_max_pain else 'Bullish' if current_price < avg_max_pain else 'Neutral'
    en.append(f"1Ô∏è‚É£ Max Pain Avg: ${avg_max_pain:.2f} (Price ${current_price:.2f}) -> {sentiment_en}")
    en.append(f"2Ô∏è‚É£ Pinning Probabilities: {[(e, round(p*100,2)) for e,p in zip(expiries,pin_probs)]} (Price ${current_price:.2f})")
    en.append(f"3Ô∏è‚É£ BS Valuation: Call${bs_call:.2f}, Put${bs_put:.2f} (Price ${current_price:.2f})")
    en.append(f"4Ô∏è‚É£ Earnings Move: ${low_move:.2f} - ${high_move:.2f} (Price ${current_price:.2f})")
    en.append(f"5Ô∏è‚É£ Vol Skew (RR): {vol_skew_rr:.2f}% (Price ${current_price:.2f})")
    en.append(f"6Ô∏è‚É£ OI Levels: Call${max_call:.2f}, Put${max_put:.2f}; Volume Profile POC${poc:.2f}, VAH${vah:.2f}, VAL${val:.2f} (Price ${current_price:.2f})")
    en.append(f"7Ô∏è‚É£ Forecast Range: ${forecast_low:.2f} - ${forecast_high:.2f} (Price ${current_price:.2f})")
    en.append(f"üìà Stock Score (0-10): {score}")

    return '\n'.join(cn), '\n'.join(en)

# ================= Run Analysis =================
if st.sidebar.button("Run Analysis"):
    hist, df = fetch_data(ticker)
    if hist is None or hist.empty:
        st.error("Êó†Ê≥ïËé∑ÂèñÂéÜÂè≤Êï∞ÊçÆ„ÄÇËØ∑Ê£ÄÊü•ÁΩëÁªúÊàñÁ®çÂêéÈáçËØï„ÄÇ")
    else:
        current_price = float(hist['Close'][-1])
        expiries = selected_expiries if selected_expiries else stock.options[:expiry_count]
        max_pain_prices = [current_price] * len(expiries)
        pin_probs = [E] * len(expiries)
        bs_call = black_scholes_price(current_price, strike_price, forecast_days/252, 0.03, 0.2)
        bs_put = black_scholes_price(current_price, strike_price, forecast_days/252, 0.03, 0.2, 'put')
        earnings_move = 4.17
        vol_skew_rr = call_iv = put_iv = -999
        max_call = max_put = current_price
        poc, vah, val = compute_volume_profile(df)

        cn_report, en_report = generate_reports(
            ticker, expiries, max_pain_prices, pin_probs,
            bs_call, bs_put, earnings_move, vol_skew_rr,
            call_iv, put_iv, current_price,
            poc, vah, val, max_call, max_put,
            forecast_days
        )
        st.markdown(cn_report)
        st.markdown("---")
        st.markdown(en_report)

        # Price Anticipation Plot with Bounds
        days = np.arange(0, forecast_days+1)
        avg_max_pain = float(np.mean(max_pain_prices))
        low_move = current_price*(1-earnings_move/100)
        high_move = current_price*(1+earnings_move/100)
        forecast_low = min(avg_max_pain, low_move)
        forecast_high = max(avg_max_pain, high_move)
        max_path = np.linspace(current_price, avg_max_pain, len(days))
        bs_path = np.linspace(current_price, current_price*(1+vol_skew_rr/200), len(days))
        avg_path = (max_path + bs_path) / 2

        fig, ax = plt.subplots(figsize=(10,6))
        ax.plot(days, max_path, label="Max Pain Path")
        ax.plot(days, bs_path, label="BS Path")
        ax.plot(days, avg_path, linestyle='--', label="Average Path")
        ax.hlines([forecast_low, forecast_high], 0, forecast_days, linestyles='dotted', label='Forecast Bounds')
        ax.set_title("Price Anticipation Plot with Bounds")
        ax.set_xlabel("Days")
        ax.set_ylabel("Price")
        ax.legend()
        st.pyplot(fig)
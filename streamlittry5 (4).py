# -*- coding: utf-8 -*-
"""streamlittry5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14hvwpG5eq6bbkpVXWxWdLAWe6KoHmDuq
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from scipy.stats import norm
from scipy.optimize import fsolve
from yfinance.exceptions import YFRateLimitError

# =============================================================
# Sidebar — Core Inputs
# =============================================================
st.sidebar.title("Options Analysis Dashboard")
ticker = st.sidebar.text_input("Ticker", value="AAPL")
expiry_count = st.sidebar.slider("Expiry Count", 1, 10, 3)
forecast_days = st.sidebar.slider("Forecast Days", 10, 90, 30)
E = st.sidebar.slider("E (Pinning)", 0.001, 0.05, 0.01)
opt_type_global = st.sidebar.selectbox("Option Type (global)", ["Put", "Call"])

# =============================================================
# Helpers — Market Parameters (Risk‑free & Dividend Yield)
# =============================================================
@st.cache_data(ttl=3600)
def fetch_risk_free_rate():
    """Get latest 13‑Week T‑Bill (^IRX) yield as annual decimal."""
    try:
        irx = yf.Ticker("^IRX").history(period="5d")['Close'].dropna().iloc[-1]
        return float(irx) / 100  # ^IRX quoted in percent
    except Exception:
        return 0.03  # fallback 3%

@st.cache_data(ttl=86400)
def fetch_dividend_yield(ticker_obj):
    """Get forward dividend yield from ticker info."""
    dy = ticker_obj.info.get('dividendYield')
    return float(dy) if dy else 0.0

# =============================================================
# Black‑Scholes & Reverse Solver
# =============================================================
def bs_price(S, K, T, r, q, sigma, option_type='call'):
    """Dividend‑adjusted Black‑Scholes price."""
    if S <= 0 or K <= 0 or T <= 0 or sigma <= 0:
        return 0.0
    d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    if option_type == 'call':
        return S * np.exp(-q * T) * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    return K * np.exp(-r * T) * norm.cdf(-d2) - S * np.exp(-q * T) * norm.cdf(-d1)

def implied_stock_price(opt_price, K, T, r, q, sigma, option_type='call'):
    """Invert BS to find S such that BS(S)=opt_price."""
    if opt_price <= 0:
        return np.nan
    guess = K * np.exp(-(r - q) * T) + opt_price  # naive starting point
    func = lambda S: bs_price(S, K, T, r, q, sigma, option_type) - opt_price
    try:
        S_est = fsolve(func, guess, xtol=1e-6)[0]
        return float(S_est)
    except Exception:
        return np.nan

# =============================================================
# Data Fetch
# =============================================================
@st.cache_data(ttl=600)
def fetch_history_price(sym):
    try:
        return yf.Ticker(sym).history(period='1d')['Close'].iloc[-1]
    except Exception:
        return np.nan

@st.cache_data(ttl=1800)
def fetch_intraday(sym):
    df = yf.download(sym, period='6mo', interval='1h', progress=False)
    return df.reset_index() if not df.empty else pd.DataFrame()

# =============================================================
# Volume Profile
# =============================================================
def volume_profile(df, bins=50):
    if df.empty:
        return np.nan, np.nan, np.nan
    hist, edges = np.histogram(df['Close'], bins=bins, weights=df['Volume'])
    poc = (edges[np.argmax(hist)] + edges[np.argmax(hist) + 1]) / 2
    total = hist.sum()
    idx = np.argsort(hist)[::-1]
    cum = np.cumsum(hist[idx])
    va_idx = idx[cum <= total * 0.7]
    va_prices = [(edges[i] + edges[i + 1]) / 2 for i in va_idx]
    return float(poc), float(max(va_prices)), float(min(va_prices))

# =============================================================
# Stock Rating (simple)
# =============================================================
def stock_rating(S, pain, skew, poc, vah, val):
    dp = max(0, 1 - abs(S - pain) / pain)
    ds = (skew + 100) / 200  # normalize skew
    dv = max(0, 1 - abs(S - poc) / (vah - val)) if vah != val else 0
    return round(np.clip((0.4 * dp + 0.3 * ds + 0.3 * dv) * 10, 0, 10), 1)

# =============================================================
# Fetch option chain & expiries UI
# =============================================================
if not ticker:
    st.stop()

try:
    stock = yf.Ticker(ticker)
    all_expiries = stock.options
except Exception as e:
    st.error(f"Unable to fetch option expiries: {e}")
    st.stop()

st.sidebar.write("Available Expiries:", all_expiries)
selected_expiries = st.sidebar.multiselect(
    "Select Expiries for Analysis", all_expiries, default=all_expiries[:expiry_count]
)
valuation_expiry = st.sidebar.selectbox("Select Expiry for Valuation", all_expiries)

# =============================================================
# Implied Stock Price Calculator UI
# =============================================================
st.sidebar.markdown("---")
st.sidebar.subheader("Implied Stock Price (BS Reverse)")
calc_expiry = st.sidebar.selectbox("Option Expiry", selected_expiries, key="imp_exp")
calc_type = st.sidebar.selectbox("Option Type", ["call", "put"], key="imp_type")
try:
    chain = stock.option_chain(calc_expiry)
    chain_df = chain.calls if calc_type == 'call' else chain.puts
    strike_sel = st.sidebar.selectbox("Strike", chain_df['strike'].tolist(), key="imp_strike")
    row_opt = chain_df[chain_df['strike'] == strike_sel].iloc[0]
    market_price = (row_opt['bid'] + row_opt['ask']) / 2
    imp_vol = row_opt['impliedVolatility']
except Exception:
    market_price = imp_vol = strike_sel = np.nan

if st.sidebar.button("Compute Implied S"):
    rfr = fetch_risk_free_rate()
    div_y = fetch_dividend_yield(stock)
    T_imp = (datetime.strptime(calc_expiry, "%Y-%m-%d") - datetime.today()).days / 252
    S_calc = implied_stock_price(market_price, strike_sel, T_imp, rfr, div_y, imp_vol, calc_type)
    if np.isnan(S_calc):
        st.sidebar.error("Failed to compute implied price.")
    else:
        st.sidebar.success(f"Implied Stock Price: ${S_calc:.2f}")

# =============================================================
# Run Main Analysis
# =============================================================
if st.sidebar.button("Run Full Analysis"):
    spot_price = fetch_history_price(ticker)
    if np.isnan(spot_price):
        st.error("Cannot fetch current price.")
        st.stop()

    df_intraday = fetch_intraday(ticker)
    poc, vah, val = volume_profile(df_intraday)

    # Simplified placeholders for demonstration
    avg_max_pain = spot_price  # placeholder
    vol_skew_rr = 0            # placeholder skew
    rating = stock_rating(spot_price, avg_max_pain, vol_skew_rr, poc, vah, val)

    # Report (Chinese & English)
    cn_report = f"""📊 **分析报告 {ticker}**\n当前价: ${spot_price:.2f}\nPOC:{poc:.2f} VAH:{vah:.2f} VAL:{val:.2f}\n评分: {rating}/10"""
    en_report = f"""📊 **Report {ticker}**\nPrice: ${spot_price:.2f}\nPOC:{poc:.2f} VAH:{vah:.2f} VAL:{val:.2f}\nScore: {rating}/10"""
    st.markdown(cn_report)
    st.markdown("---")
    st.markdown(en_report)

    # Plot
    days = np.arange(forecast_days + 1)
    path = np.linspace(spot_price, avg_max_pain, len(days))
    fig, ax = plt.subplots(figsize=(8, 4))
    ax.plot(days, path, label="Path to MaxPain")
    ax.hlines([poc, vah, val], 0, forecast_days, linestyles='dotted', label='Volume Profile')
    ax.set_xlabel("Days"); ax.set_ylabel("Price"); ax.legend(); ax.set_title("Anticipation & Profile")
    st.pyplot(fig)
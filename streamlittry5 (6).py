# -*- coding: utf-8 -*-
"""streamlittry5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14hvwpG5eq6bbkpVXWxWdLAWe6KoHmDuq
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from scipy.stats import norm
from scipy.optimize import fsolve, curve_fit
# ================= 获取无风险利率与股息率 =================
def get_risk_free_and_dividend(ticker):
    # 无风险利率 (3M T-Bill)
    tbill = yf.Ticker("^IRX")  # 3个月国库券
    r = tbill.history(period="1d")['Close'].iloc[-1] / 100  # 转换为小数

    # 股息率 (Dividend Yield)
    stock = yf.Ticker(ticker)
    try:
        div_yield = stock.info.get("dividendYield", 0.0) or 0.0  # 若无分红返回0
    except:
        div_yield = 0.0
    return r, div_yield
# ================= Streamlit Sidebar Inputs =================
st.sidebar.title("Options Analysis Dashboard")
ticker = st.sidebar.text_input("Ticker", value="AAPL")
expiry_count = st.sidebar.slider("Expiry Count", 1, 10, 3)
forecast_days = st.sidebar.slider("Forecast Days", 10, 90, 30)
E = st.sidebar.slider("E (Pinning)", 0.001, 0.05, 0.01)
opt_type = st.sidebar.selectbox("Option Type", ["Put", "Call"])

# Ensure ticker is valid before fetching data
if ticker:
    stock = yf.Ticker(ticker)
    try:
        expirations = stock.options
        st.sidebar.write("Available Expiries:", expirations)
        selected_expiries = st.sidebar.multiselect(
            "Select Expiries for Analysis", expirations, default=expirations[:expiry_count]
        )
        valuation_expiry = st.sidebar.selectbox("Select Expiry for Valuation", expirations)
    except Exception as e:
        st.error(f"Error fetching options data: {e}")
        selected_expiries, valuation_expiry = [], None
else:
    st.stop()

# ================= Option Strategy Builder =================
st.sidebar.subheader("Option Strategy Builder")
strategy = st.sidebar.selectbox("Select Strategy", ["Single Call", "Single Put", "Vertical Spread", "Straddle"])
strike_price = st.sidebar.number_input("Strike Price", min_value=1.0, value=100.0)
premium = st.sidebar.number_input("Option Premium", min_value=0.0, value=5.0)
if strategy == "Vertical Spread":
    strike_price_2 = st.sidebar.number_input("Second Strike Price", min_value=1.0, value=105.0)
    premium_2 = st.sidebar.number_input("Second Option Premium", min_value=0.0, value=3.0)
if st.sidebar.button("Build Option"):
    price_range = np.linspace(strike_price * 0.8, strike_price * 1.2, 100)
    payoff = None
    if strategy == "Single Call":
        payoff = np.maximum(price_range - strike_price, 0) - premium
    elif strategy == "Single Put":
        payoff = np.maximum(strike_price - price_range, 0) - premium
    elif strategy == "Vertical Spread":
        payoff = (
            np.maximum(price_range - strike_price, 0) - premium
        ) - (
            np.maximum(price_range - strike_price_2, 0) - premium_2
        )
    elif strategy == "Straddle":
        payoff = (
            np.maximum(price_range - strike_price, 0) - premium
        ) + (
            np.maximum(strike_price - price_range, 0) - premium
        )
    fig, ax = plt.subplots(figsize=(8, 4))
    ax.plot(price_range, payoff, label=strategy)
    ax.axhline(0, color='black', linestyle='--')
    ax.set_title(f"Payoff Diagram: {strategy}")
    ax.set_xlabel("Underlying Price")
    ax.set_ylabel("Profit / Loss")
    ax.legend()
    st.pyplot(fig)

# ================= Black-Scholes Pricing =================
def black_scholes_price(S, K, T, r, q, sigma, option_type='call'):
    # q 为股息率
    d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    if option_type.lower() == 'call':
        return S * np.exp(-q*T) * norm.cdf(d1) - K * np.exp(-r*T) * norm.cdf(d2)
    return K * np.exp(-r*T) * norm.cdf(-d2) - S * np.exp(-q*T) * norm.cdf(-d1)


# ================= Fetch & Volume Analysis =================
def fetch_stock_data(ticker, period="6mo", interval="1h"):
    df = yf.download(ticker, period=period, interval=interval)
    if df.empty:
        st.warning(f"[错误] 无法获取 {ticker} 数据。")
        return pd.DataFrame()
    df.reset_index(inplace=True)
    return df

def compute_volume_profile(df, bins=50):
    if df.empty:
        return None, None, None
    hist, edges = np.histogram(df['Close'], bins=bins, weights=df['Volume'])
    poc = float((edges[np.argmax(hist)] + edges[np.argmax(hist) + 1]) / 2)
    total = hist.sum()
    sorted_idx = np.argsort(hist)[::-1]
    cum = np.cumsum(hist[sorted_idx])
    va_idx = sorted_idx[cum <= total * 0.7]
    va_prices = [(edges[i] + edges[i + 1]) / 2 for i in va_idx]
    return poc, float(max(va_prices)), float(min(va_prices))

def calculate_max_pain(calls, puts):
    strikes = sorted(set(calls['strike']).union(set(puts['strike'])))
    pain_list = []
    for strike in strikes:
        call_pain = ((calls['strike'] - strike).clip(lower=0) * calls['openInterest']).sum()
        put_pain = ((strike - puts['strike']).clip(lower=0) * puts['openInterest']).sum()
        pain_list.append(call_pain + put_pain)
    return strikes[np.argmin(pain_list)]

max_pain_prices = []
for expiry in selected_expiries:
    chain = stock.option_chain(expiry)
    pain_price = calculate_max_pain(chain.calls, chain.puts)
    max_pain_prices.append(float(pain_price))

# ================= Generate Detailed Report =================
def generate_option_report(
    ticker, expiries, max_pain_prices, pinning_probs,
    bs_call, bs_put, earnings_move, vol_skew_rr,
    call_iv, put_iv, current_price,
    poc, vah, val, max_call, max_put,
    forecast_days=30
):
    report = f"📊 **Option Market Analysis Report: {ticker}**\n\n"
    avg_max_pain = float(np.mean(max_pain_prices))
    expiry_str = ", ".join(expiries)
    low_move = current_price * (1 - earnings_move/100)
    high_move = current_price * (1 + earnings_move/100)
    forecast_low = min(avg_max_pain, low_move)
    forecast_high = max(avg_max_pain, high_move)

    # 1️⃣ Max Pain
    report += "1️⃣ **Max Pain (最大痛点价):**\n"
    report += f"- 到期日: {expiry_str}\n"
    report += f"- 痛点价: {[float(x) for x in max_pain_prices]}。\n"
    report += f"- 平均: ${avg_max_pain:.2f}，当前: ${current_price:.2f}。\n"
    if current_price > avg_max_pain:
        report += "- 分析: 股价高于痛点，短期或向下修复，偏空信号。\n\n"
    elif current_price < avg_max_pain:
        report += "- 分析: 股价低于痛点，可能向痛点回归，偏多信号。\n\n"
    else:
        report += "- 分析: 股价接近痛点，短期或横盘，信号中性。\n\n"

    # 2️⃣ 钉住概率
    report += "2️⃣ **钉住概率 (Pinning Probability):**\n"
    for e, p in zip(expiries, pinning_probs):
        report += f"- {e}: {p*100:.2f}%\n"
    report += "- 分析: 高概率价位易出现价格钉住，参考该区间布局。\n\n"

    # 3️⃣ Black-Scholes 定价
    report += "3️⃣ **Black-Scholes 定价:**\n"
    report += f"- Call: ${bs_call:.2f}, Put: ${bs_put:.2f}。\n"
    report += "- 分析: 理论价值，若实际溢价显著偏离，可考虑套利策略。\n\n"

    # 4️⃣ 财报预期区间
    report += "4️⃣ **财报预期区间 (Earnings Move):**\n"
    report += f"- 范围: ${low_move:.2f} - ${high_move:.2f} (±{earnings_move:.2f}%)\n"
    report += "- 分析: 市场约一周内预期波动，区间外为极端情况。\n\n"

    # 5️⃣ 波动率偏斜 & 风险逆转
    report += "5️⃣ **波动率偏斜 & 风险逆转 (Vol Skew & RR):**\n"
    report += f"- Call IV: {call_iv:.2f}%, Put IV: {put_iv:.2f}%, RR: {vol_skew_rr:.2f}%\n"
    if vol_skew_rr > 0:
        report += "- 分析: 正RR，市场偏多，倾向买入看涨期权。\n\n"
    elif vol_skew_rr < 0:
        report += "- 分析: 负RR，市场偏空，倾向买入看跌期权。\n\n"
    else:
        report += "- 分析: RR接近0，中性市场预期。\n\n"

    # 6️⃣ OI & Volume Profile
    report += "6️⃣ **OI & 成交量分布 (Volume Profile):**\n"
    report += f"- Call OI Strike: ${max_call:.2f}, Put OI Strike: ${max_put:.2f}\n"
    report += f"- POC: ${poc:.2f}, VAH: ${vah:.2f}, VAL: ${val:.2f}\n"
    report += f"- 当前价格: ${current_price:.2f}\n"
    if current_price > vah:
        report += "- 分析: 价格超出价值区上沿，短期过热风险。\n\n"
    elif current_price < val:
        report += "- 分析: 价格跌破价值区下沿，短期超卖机会。\n\n"
    else:
        report += "- 分析: 价格在价值区内部，正常波动区间。\n\n"

    # 7️⃣ 综合预测区间
    report += "7️⃣ **综合预测区间 (Forecast Bounds):**\n"
    report += f"- ${forecast_low:.2f} - ${forecast_high:.2f} (至 {(datetime.today()+timedelta(days=forecast_days)).strftime('%Y-%m-%d')})\n"
    report += "- 分析: 结合最大痛点与财报预期，作为短期交易区间。\n\n"

    # 结论
    direction = '偏多' if vol_skew_rr > 0 else '偏空'
    report += f"📌 **综合结论:** 市场{direction}，建议在上沿/痛点位置布局防御性策略，在下沿/价值区下沿布局进攻性多头。"
    return report

# ================= Run Analysis =================
if st.sidebar.button("Run Analysis"):
    hist = stock.history(period='1d')
    if hist.empty:
        st.error("无历史数据。")
    else:
        current_price = float(hist['Close'].iloc[-1])
        chain = stock.option_chain(valuation_expiry)
        calls, puts = chain.calls, chain.puts
        max_call = float(calls.loc[calls['openInterest'].idxmax()]['strike'])
        max_put = float(puts.loc[puts['openInterest'].idxmax()]['strike'])
        df = fetch_stock_data(ticker)
        poc, vah, val = compute_volume_profile(df)
        max_pain_prices = []
        for expiry in selected_expiries:
          chain = stock.option_chain(expiry)
          pain_price = calculate_max_pain(chain)
          max_pain_prices.append(float(pain_price))
        pinning_probs = [0.012] * len(selected_expiries)
        # 获取无风险利率与股息率
        r, q = get_risk_free_and_dividend(ticker)

        # Black-Scholes 定价（动态利率和股息率）
        atm_strike = min(calls['strike'], key=lambda x: abs(x - current_price))
        bs_call = black_scholes_price(current_price, atm_strike, forecast_days/252, r, q, 0.2)
        bs_put = black_scholes_price(current_price, atm_strike, forecast_days/252, r, q, 0.2, 'put')

        # 自动估算财报预期波动
        atm_strike = min(calls['strike'], key=lambda x: abs(x - current_price))
        atm_iv = float(calls.loc[calls['strike'] == atm_strike, 'impliedVolatility'].iloc[0])
        earnings_move = atm_iv * np.sqrt(forecast_days / 365) * 100  # 转为百分比


        # 自动计算 Call IV 和 Put IV
        call_iv = float(calls.loc[calls['strike'] == max_call, 'impliedVolatility'].iloc[0]) * 100
        put_iv = float(puts.loc[puts['strike'] == max_put, 'impliedVolatility'].iloc[0]) * 100

        # 风险逆转 (RR) = Call IV - Put IV
        vol_skew_rr = call_iv - put_iv


        report = generate_option_report(
            ticker, selected_expiries, max_pain_prices, pinning_probs,
            bs_call, bs_put, earnings_move, vol_skew_rr,
            call_iv, put_iv, current_price,
            poc, vah, val, max_call, max_put,
            forecast_days
        )
        st.markdown(report)

        # Plot Anticipation with Bounds
        days = np.arange(0, forecast_days+1)
        avg_max_pain = float(np.mean(max_pain_prices))
        low_move = current_price * (1 - earnings_move/100)
        high_move = current_price * (1 + earnings_move/100)
        forecast_low = min(avg_max_pain, low_move)
        forecast_high = max(avg_max_pain, high_move)
        max_path = np.linspace(current_price, avg_max_pain, len(days))
        bs_path = np.linspace(current_price, current_price*(1+vol_skew_rr/200), len(days))
        avg_path = (max_path + bs_path) / 2

        fig, ax = plt.subplots(figsize=(10, 6))
        ax.plot(days, max_path, label="Max Pain Path")
        ax.plot(days, bs_path, label="BS Path")
        ax.plot(days, avg_path, linestyle='--', label="Average Path")
        ax.hlines([forecast_low, forecast_high], 0, forecast_days, linestyles='dotted', label='Forecast Bounds')
        ax.set_title("Price Anticipation Plot with Bounds")
        ax.set_xlabel("Days")
        ax.set_ylabel("Price")
        ax.legend()
        st.pyplot(fig)
# -*- coding: utf-8 -*-
"""“streamlittry5”的副本

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wa5UpSu_7ESCqll6iciUljYHncojNbGi
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from scipy.stats import norm
from scipy.optimize import fsolve, curve_fit

# ================= Streamlit Sidebar Inputs =================
st.sidebar.title("Options Analysis Dashboard")
ticker = st.sidebar.text_input("Ticker", value="AAPL")
expiry_count = st.sidebar.slider("Expiry Count", 1, 10, 3)
forecast_days = st.sidebar.slider("Forecast Days", 10, 90, 30)
E = st.sidebar.slider("E (Pinning)", 0.001, 0.05, 0.01)
opt_type = st.sidebar.selectbox("Option Type", ["Put", "Call"])

# Ensure ticker is valid before fetching data
if ticker:
    stock = yf.Ticker(ticker)
    try:
        expirations = stock.options
        st.sidebar.write("Available Expiries:", expirations)
        selected_expiries = st.sidebar.multiselect(
            "Select Expiries for Analysis", expirations, default=expirations[:expiry_count]
        )
        valuation_expiry = st.sidebar.selectbox("Select Expiry for Valuation", expirations)
    except Exception as e:
        st.error(f"Error fetching options data: {e}")
        selected_expiries, valuation_expiry = [], None
else:
    st.stop()

# ================= Option Strategy Builder =================
st.sidebar.subheader("Option Strategy Builder")
strategy = st.sidebar.selectbox("Select Strategy", ["Single Call", "Single Put", "Vertical Spread", "Straddle"])
strike_price = st.sidebar.number_input("Strike Price", min_value=1.0, value=100.0)
premium = st.sidebar.number_input("Option Premium", min_value=0.0, value=5.0)
if strategy == "Vertical Spread":
    strike_price_2 = st.sidebar.number_input("Second Strike Price", min_value=1.0, value=105.0)
    premium_2 = st.sidebar.number_input("Second Option Premium", min_value=0.0, value=3.0)
if st.sidebar.button("Build Option"):
    price_range = np.linspace(strike_price * 0.8, strike_price * 1.2, 100)
    payoff = None
    if strategy == "Single Call":
        payoff = np.maximum(price_range - strike_price, 0) - premium
    elif strategy == "Single Put":
        payoff = np.maximum(strike_price - price_range, 0) - premium
    elif strategy == "Vertical Spread":
        payoff = (
            np.maximum(price_range - strike_price, 0) - premium
        ) - (
            np.maximum(price_range - strike_price_2, 0) - premium_2
        )
    elif strategy == "Straddle":
        payoff = (
            np.maximum(price_range - strike_price, 0) - premium
        ) + (
            np.maximum(strike_price - price_range, 0) - premium
        )
    fig, ax = plt.subplots(figsize=(8, 4))
    ax.plot(price_range, payoff, label=strategy)
    ax.axhline(0, color='black', linestyle='--')
    ax.set_title(f"Payoff Diagram: {strategy}")
    ax.set_xlabel("Underlying Price")
    ax.set_ylabel("Profit / Loss")
    ax.legend()
    st.pyplot(fig)

# ================= Black-Scholes Pricing =================
def black_scholes_price(S, K, T, r, sigma, option_type='call'):
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    if option_type.lower() == 'call':
        return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    return K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)

# ================= Fetch & Volume Analysis =================
def fetch_stock_data(ticker, period="6mo", interval="1h"):
    df = yf.download(ticker, period=period, interval=interval)
    if df.empty:
        st.warning(f"[错误] 无法获取 {ticker} 数据。")
        return pd.DataFrame()
    df.reset_index(inplace=True)
    return df

def compute_volume_profile(df, bins=50):
    if df.empty:
        return None, None, None
    hist, edges = np.histogram(df['Close'], bins=bins, weights=df['Volume'])
    poc = float((edges[np.argmax(hist)] + edges[np.argmax(hist) + 1]) / 2)
    total = hist.sum()
    sorted_idx = np.argsort(hist)[::-1]
    cum = np.cumsum(hist[sorted_idx])
    va_idx = sorted_idx[cum <= total * 0.7]
    va_prices = [(edges[i] + edges[i + 1]) / 2 for i in va_idx]
    return poc, float(max(va_prices)), float(min(va_prices))

# ================= Generate Detailed Report =================
def generate_option_report(
    ticker, expiries, max_pain_prices, pinning_probs,
    bs_call, bs_put, earnings_move, vol_skew_rr,
    call_iv, put_iv, current_price,
    poc, vah, val, max_call, max_put,
    forecast_days=30
):
    report = f"📊 **Option Market Analysis Report: {ticker}**

"
    avg_max_pain = float(np.mean(max_pain_prices))
    expiry_str = ", ".join(expiries)
    low_move = current_price * (1 - earnings_move/100)
    high_move = current_price * (1 + earnings_move/100)
    forecast_low = min(avg_max_pain, low_move)
    forecast_high = max(avg_max_pain, high_move)

    # 1️⃣ Max Pain
    report += "1️⃣ **Max Pain (最大痛点价):**
"
    report += f"- 痛点价列表: {[float(x) for x in max_pain_prices]} ，当前: ${current_price:.2f}
"
    report += f"- 平均痛点价: ${avg_max_pain:.2f} ，当前: ${current_price:.2f}
"
    if current_price > avg_max_pain:
        report += f"  ↳ 股价（${current_price:.2f}）高于平均痛点价（${avg_max_pain:.2f}），短期偏空。

"
    elif current_price < avg_max_pain:
        report += f"  ↳ 股价（${current_price:.2f}）低于平均痛点价（${avg_max_pain:.2f}），短期偏多。

"
    else:
        report += f"  ↳ 股价（${current_price:.2f}）等于平均痛点价，信号中性。

"

    # 2️⃣ 钉住概率
    report += "2️⃣ **钉住概率 (Pinning Probability):**
"
    for e, p in zip(expiries, pinning_probs):
        report += f"- 到期日 {e} 钉住价位概率: {p*100:.2f}% ，当前: ${current_price:.2f}
"
    report += f"  ↳ 股价（${current_price:.2f}）接近高概率区间，易被钉住。

"

    # 3️⃣ Black-Scholes 定价
    report += "3️⃣ **Black-Scholes 定价:**
"
    report += f"- Call 估值: ${bs_call:.2f} ，当前: ${current_price:.2f}
"
    report += f"- Put 估值: ${bs_put:.2f} ，当前: ${current_price:.2f}
"
    report += f"  ↳ 估值与市价对比: {'高于' if current_price<bs_call else '低于'} Call 估值，{'看多' if current_price<bs_call else '看空'}。

"

    # 4️⃣ 财报预期区间
    report += "4️⃣ **财报预期区间 (Earnings Expected Move):**
"
    report += f"- 区间: ${low_move:.2f} - ${high_move:.2f} (±{earnings_move:.2f}%)
"
    report += f"  ↳ 当前: ${current_price:.2f}，{'在' if low_move<=current_price<=high_move else '超出'}预期区间。

"

    # 5️⃣ 波动率偏斜 & 风险逆转
    report += "5️⃣ **波动率偏斜 & 风险逆转 (Vol Skew & RR):**
"
    report += f"- Call IV: {call_iv:.2f}%，Put IV: {put_iv:.2f}%，RR: {vol_skew_rr:.2f}%
"
    if vol_skew_rr > 0:
        report += f"  ↳ RR 正向 ({vol_skew_rr:.2f}%)，市场偏多。

"
    elif vol_skew_rr < 0:
        report += f"  ↳ RR 负向 ({vol_skew_rr:.2f}%)，市场偏空。

"
    else:
        report += "  ↳ RR 接近 0，市场中性预期。

"

    # 6️⃣ OI & Volume Profile
    report += "6️⃣ **OI & 成交量分布 (Volume Profile):**
"
    report += f"- Call 最大 OI 执行价: ${max_call:.2f} ，当前: ${current_price:.2f}
"
    report += f"- Put 最大 OI 执行价: ${max_put:.2f} ，当前: ${current_price:.2f}
"
    report += f"- POC: ${poc:.2f}, VAH: ${vah:.2f}, VAL: ${val:.2f} ，当前: ${current_price:.2f}
"
    if current_price > vah:
        report += f"  ↳ 价格超出价值区上沿（${vah:.2f}），过热风险。

"
    elif current_price < val:
        report += f"  ↳ 价格跌破价值区下沿（${val:.2f}），超卖机会。

"
    else:
        report += f"  ↳ 价格在价值区内部（${val:.2f}-${vah:.2f}），正常波动。

"

    # 7️⃣ 综合预测区间
    report += "7️⃣ **综合预测区间:**
"
    report += f"- ${forecast_low:.2f} - ${forecast_high:.2f} (至 {(datetime.today()+timedelta(days=forecast_days)).strftime('%Y-%m-%d')}) ，当前: ${current_price:.2f}
"
    report += f"  ↳ 当前股价 {'低于' if current_price<forecast_low else '高于' if current_price>forecast_high else '在'}预测区间。

"

    # 结论
    direction = '偏多' if vol_skew_rr>0 else '偏空'
    report += f"📌 **综合结论:** 市场{direction}，建议上沿/痛点（${forecast_high:.2f}）布局防御，下沿/价值区下沿（${forecast_low:.2f}）布局进攻。"
    return report

# ================= Run Analysis =================
if st.sidebar.button("Run Analysis"):
    hist = stock.history(period='1d')
    if hist.empty:
        st.error("无历史数据。")
    else:
        current_price = float(hist['Close'].iloc[-1])
        chain = stock.option_chain(valuation_expiry)
        calls, puts = chain.calls, chain.puts
        max_call = float(calls.loc[calls['openInterest'].idxmax()]['strike'])
        max_put = float(puts.loc[puts['openInterest'].idxmax()]['strike'])
        df = fetch_stock_data(ticker)
        poc, vah, val = compute_volume_profile(df)
        max_pain_prices = [float(current_price)] * len(selected_expiries)
        pinning_probs = [0.012] * len(selected_expiries)
        bs_call = black_scholes_price(current_price, strike_price, forecast_days/252, 0.03, 0.2)
        bs_put = black_scholes_price(current_price, strike_price, forecast_days/252, 0.03, 0.2, 'put')
        earnings_move = 4.17
        vol_skew_rr, call_iv, put_iv = -13.09, 67.19, 80.27

        report = generate_option_report(
            ticker, selected_expiries, max_pain_prices, pinning_probs,
            bs_call, bs_put, earnings_move, vol_skew_rr,
            call_iv, put_iv, current_price,
            poc, vah, val, max_call, max_put,
            forecast_days
        )
        st.markdown(report)

        # Plot Anticipation with Bounds
        days = np.arange(0, forecast_days+1)
        avg_max_pain = float(np.mean(max_pain_prices))
        low_move = current_price * (1 - earnings_move/100)
        high_move = current_price * (1 + earnings_move/100)
        forecast_low = min(avg_max_pain, low_move)
        forecast_high = max(avg_max_pain, high_move)
        max_path = np.linspace(current_price, avg_max_pain, len(days))
        bs_path = np.linspace(current_price, current_price*(1+vol_skew_rr/200), len(days))
        avg_path = (max_path + bs_path) / 2

        fig, ax = plt.subplots(figsize=(10, 6))
        ax.plot(days, max_path, label="Max Pain Path")
        ax.plot(days, bs_path, label="BS Path")
        ax.plot(days, avg_path, linestyle='--', label="Average Path")
        ax.hlines([forecast_low, forecast_high], 0, forecast_days, linestyles='dotted', label='Forecast Bounds')
        ax.set_title("Price Anticipation Plot with Bounds")
        ax.set_xlabel("Days")
        ax.set_ylabel("Price")
        ax.legend()
        st.pyplot(fig)